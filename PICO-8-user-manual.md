# PICO-8 用户手册

> [!IMPORTANT]
>
> 该版本的手册属于非官方翻译，由 fadedflower 个人翻译并自用，出现翻译错误属于正常现象，请务必指出。

PICO-8 v0.2.7  
https://www.pico-8.com  
(c) Copyright 2014-2025 Lexaloffle Games LLP  
作者：Joseph White // hey@lexaloffle.com 

PICO-8 的构建用到下面这些库： 

SDL2 http://www.libsdl.org  
Lua 5.2 http://www.lua.org  // 见 license.txt  
ws281x by jgarff       // 见 license.txt  
GIFLIB http://giflib.sourceforge.net/  
WiringPi http://wiringpi.com/  
libb64 by Chris Venter  
miniz by Rich Geldreich  
z8lua by Sam Hocevar https://github.com/samhocevar/z8lua

本手册的最新版本（格式含 html，txt）以及其他资源：

https://www.lexaloffle.com/pico-8.php?page=resources

## 欢迎来到 PICO-8

PICO-8 是一款虚构游戏机，能够制作、分享和游玩小游戏以及其他计算机程序。启动时，机器首先会给你提供一个 Shell，用来输入 Lua 程序。它还提供了简单的内置工具，用来创建精灵图像、地图和声音。

PICO-8 的严苛限制是经过精挑细选的，这样使用起来会更有乐趣，鼓励小而精的设计，希望能给予 PICO-8 卡带独特的外表和风格。

## 技术规范

> 显示屏：   128x128，固定 16 色调色板  
> 输入：       6 按键控制器  
> 卡带：       32k 数据，以 png 文件格式存储  
> 声音：       4 通道，64 清晰度芯片  
> 代码：       P8 Lua（代码最高 8192 个 Token）  
> CPU：       每秒 4M 虚拟机指令  
> 精灵图像：单块 128 个 8x8 精灵图像（附加 128 个图像，位于共享内存）  
> 地图：       128x32 瓦片地图（附加 128x32 地图，位于共享内存）

# 1 起步

## 1.1 键位

> ALT+ENTER：切换全屏  
> ALT+F4：       快速退出（Windows）  
> CTRL-Q：      快速退出（Mac，Linux）  
> CTRL-R：      重载 / 运行 / 重启卡带  
> CTRL-S：      快速保存当前卡带  
> CTRL-M：     静音 / 取消静音  
> ENTER / P：  暂停菜单（卡带运行期间）

> 玩家 1 默认键位：鼠标指针 + ZX / NM / CV  
> 玩家 2 默认键位：SDFE + tab，Q / shift A

要改变默认键位，在 PICO-8 内部使用 KEYCONFIG 实用工具：

```
> KEYCONFIG
```

## 1.2 Hello World

PICO-8 启动后，尝试输入下面这些命令并用 enter 键结束：

``````lua
> PRINT("HELLO WORLD")
> RECTFILL(80,80,120,100,12)
> CIRCFILL(70,90,20,14)
> FOR I=1,4 DO PRINT(I) END
``````

> [!NOTE]
>
> PICO-8 只显示大写字符 -- 所以只需要正常输入，不需要大写锁定！

在代码编辑模式中，使用像这样的命令以及两个特殊的回调函数 `_UPDATE` 和 `_DRAW` ，你可以构建一个交互式程序。例如，接下来这个程序允许你使用方向键四处移动一个圆。按 Esc 键切换到代码编辑器，输入或者复制粘贴下列代码：

``````lua
X = 64  Y = 64
FUNCTION _UPDATE()
  IF (BTN(0)) THEN X=X-1 END
  IF (BTN(1)) THEN X=X+1 END
  IF (BTN(2)) THEN Y=Y-1 END
  IF (BTN(3)) THEN Y=Y+1 END
END
 
FUNCTION _DRAW()
  CLS(5)
  CIRCFILL(X,Y,7,14)
END
``````

现在按下 Esc 键回到控制台，输入 `RUN` （或者按下 CTRL-R）查看运行结果。需要更复杂的程序，请参考 Demo 卡带（输入 `INSTALL_DEMOS`）。

如果你想要保存你的程序，日后再用，使用 `SAVE` 命令：

``````
> SAVE PINKCIRC
``````

要再次加载这个程序：

``````
> LOAD PINKCIRC
``````

## 1.3 示例卡带

这些卡带包含在 PICO-8 里，若要安装，输入下面的命令：

``````
> INSTALL_DEMOS
> CD DEMOS
> LS
 
HELLO      来自 PICO-8 的问候
API        演示大部分 PICO-8 的功能
JELPI      平台游戏 Demo 以及 2p 支持
CAST       2.5D 光线投射 Demo
DRIPPY     绘制往下流淌的涂鸦
WANDER     简单的步行模拟器
COLLIDE    墙和物体碰撞的示例
``````

要运行一个卡带，打开 PICO-8 并输入：

``````
> LOAD JELPI
> RUN
``````

按 Esc 键停止程序运行，再按一次进入编辑模式。

一小部分 BBS 卡带可以用下面的命令安装到 `/GAMES` ：

``````
> INSTALL_GAMES
``````

## 1.4 文件系统

以下这些命令用来管理文件和目录（文件夹）：

``````
LS          列出当前目录
CD BLAH     切换目录
CD ..       切换上一级目录
CD /        切换回根目录（在 PICO-8 的虚拟磁盘）
MKDIR BLAH  创建一个目录
FOLDER      在宿主操作系统的文件浏览器中打开当前目录
``````

`LOAD BLAH` 从当前目录中加载一个卡带，`SAVE BLAH` 将卡带保存到当前目录。

如果你想要把文件移到别处，复制一份或者删除他们，使用 `FOLDER` 命令并在宿主操作系统中完成这些操作。

PICO-8 的磁盘的默认位置是：

Windows：C:/Users/Yourname/AppData/Roaming/pico-8/carts  
OSX：/Users/Yourname/Library/Application Support/pico-8/carts  
Linux：~/.lexaloffle/pico-8/carts

你可以在 `pico-8/config.txt` 中修改这个位置以及其他设置。

> [!TIP]
>
> 磁盘目录可以映射到云盘（Dropbox，Google Drive 或者类似的平台），这能够在不同宿主机上的 PICO-8 机器中共享单一磁盘。

## 1.5 加载和保存

使用 `LOAD` 和 `SAVE` 的时候，`.P8` 扩展名可以省略，它会自动添加。

``````
> SAVE FOO
SAVED FOO.P8
``````

卡带文件也可以拖放到 PICO-8 窗口以加载。

使用 `.p8.png` 文件扩展名可以以一种特殊的图像格式保存卡带，看上去像一个卡带。使用 `.p8.rom` 会保存为原始的 32k 二进制格式。

使用 `@clip` 文件名以加载或保存到剪贴板。

如果卡带能在 2040 个字符内进行编码（只含代码和 gfx），使用 `@url` 文件名以生成 pico-8-edu.com 链接并保存到剪贴板。

一旦加载或保存了卡带，你还能用 CTRL-S 快速保存卡带。

### 保存为 .p8.png 卡带，带有文本标签和预览图像

要生成一个附在卡带上的标签图像，首先运行程序并按下 CTRL-7 捕捉屏幕当前的图像。以“--”开头的前两行程序文本也会被绘制到卡带的标签上。

``````
-- OCEAN DIVER LEGENDS
-- BY LOOPY
``````

### .p8.png / .p8.rom 格式的代码大小限制

保存为 `.png` 或 `.rom` 格式时，代码的压缩大小必须少于 15360 字节，这样总大小就会小于等于 ß32k。

要了解代码当前的大小，使用 `INFO` 命令。保存为 `.p8` 格式则没有这种压缩大小的限制。

## 1.6 使用外部文本编辑器

用单独的文本编辑器直接编辑 `.p8` 文件是可行的。满足下列条件时，使用 CTRL-R 运行卡带会自动重载文件：

1. PICO-8 编辑器中没有未保存的改动
2. 文件内容与上一次加载的版本相比有改动

如果磁盘上的卡带和编辑器内都有所改动，屏幕会显示一条通知：

``````
DIDN'T RELOAD; UNSAVED CHANGES
``````

还有另一种方法，`.lua` 文本文件可以在单独的文本编辑器中修改，之后在卡带中使用 `#INCLUDE` （在合适的代码位置），这样每次运行时，这些代码都会包含到卡带代码中：

``````lua
#INCLUDE YOURFILE.LUA
``````

## 1.7 备份

当你不保存改动并退出，或者覆盖已有文件时，卡带的一份备份会保存到 `{appdata}/pico-8/backup` 。输入 `BACKUP` 也会把当前卡带的副本保存到相同的文件夹。

要在宿主操作系统的文件浏览器中打开备份文件夹，使用：

``````
> FOLDER BACKUPS
``````

把这些文件拖放到 PICO-8 窗口以进行加载是可行的。

从版本 0.2.4c 开始，如果编辑器不处于空闲状态，每 20 分钟会保存一份周期备份，这也就意味着备份文件夹的大小每 5 小时会增长大概 1MB。这项设置可以在 `config.txt` 中禁用或调整。

## 1.8 配置

每次会话的开始，PICO-8 会从 `config.txt` 中读取配置信息，退出时也会保存配置（所以你应当在 PICO-8 未运行的时候编辑 `config.txt` 文件）。

`config.txt` 文件的位置取决于宿主操作系统：

Windows：C:/Users/Yourname/AppData/Roaming/pico-8/config.txt  
OSX：/Users/Yourname/Library/Application Support/pico-8/config.txt  
Linux：~/.lexaloffle/pico-8/config.txt

使用 `-home` 开关（下文所述）可以用不同的路径来存放 `config.txt` 以及其他数据。

有些设置可以在 PICO-8 运行期间进行修改，输入 `CONFIG SETTING VALUE` 。（输入 `CONFIG` 本身来获取设置列表）

### 命令行参数

> [!NOTE]
>
> 这些开关会覆盖 `config.txt` 里的设置。

pico8 [switches] [filename.p8]

| 开关                 | 含义                                                         |
| -------------------- | ------------------------------------------------------------ |
| -width n             | 设置窗口宽度                                                 |
| -height n            | 设置窗口高度                                                 |
| -windowed n          | 设置窗口模式为关（0）或开（1）                               |
| -volume n            | 设置音频音量 0..256                                          |
| -joystick n          | 从玩家 n (0..7) 开始使用摇杆控制                             |
| -pixel_perfect n     | 1 为无过滤的整数倍屏幕缩放（默认是开）                       |
| -preblit_scale n     | 复制到屏幕前，显示缩放 n 倍（和 -pixel_perfect 0 一起时比较有用） |
| -draw_rect x,y,w,h   | 绘制 PICO-8 屏幕的绝对窗口坐标和大小                         |
| -display n           | 当存在多个显示器时，设置首选显示器的索引                     |
| -run filename        | 加载并运行卡带                                               |
| -x filename          | 以无头模式执行 PICO-8 卡带，随后退出（实验性功能！！）       |
| -export param_str    | 以无头模式运行 EXPORT 命令，随后退出（参阅导出部分下的注解） |
| -p param_str         | 把一个参数字符串传递到指定卡带                               |
| -splore              | 以 splore 模式启动                                           |
| -home path           | 设置存放 config.txt 和其他用户数据文件的路径                 |
| -root_path path      | 设置存放卡带文件的路径                                       |
| -desktop path        | 设置保存屏幕截图和 gif 的位置                                |
| -screenshot_scale n  | 屏幕截图的缩放。默认值：3（368x368 像素）                    |
| -gif_scale n         | gif 捕捉的缩放。默认值：2（256x256 像素）                    |
| -gif_len n           | 以秒为单位，设置 gif 的最大长度（1..120）                    |
| -gui_theme n         | 使用 1 设置高对比度编辑器配色方案                            |
| -timeout n           | 下载超时前要等待多少秒（默认值：30）                         |
| -software_blit n     | 设置使用软件 Blit 模式为关（0）或开（1）                     |
| -foreground_sleep_ms | 帧与帧之间要休眠多少毫秒                                     |
| -background_sleep_ms | 后台运行时，帧与帧之间要休眠多少毫秒                         |
| -accept_future n     | 1 为允许加载使用未来版本的 PICO-8 制作的卡带                 |
| -global_api n        | 1 为 API 函数留在全局作用域（调试时有用）                    |



### 控制器设置

PICO-8 使用 SDL2 控制器配置方案，启动时会探测常见控制器，同时也会在与 config.txt 同目录的 `sdl_controllers.txt` 中寻找自定义映射。  
`sdl_controller.txt` 每行有一条映射。

要为你的控制器生成自定义映射字符串，要么使用 SDL2 附带的 `controllermap` 程序，要么尝试 http://www.generalarcade.com/gamepadtool/。

要得知 SDL2 探测得到的控制器 ID，运行 PICO-8 之后，在 log.txt 中查找 `joysticks` 或者 `Mapping` 。不同的操作系统，ID 有可能有所区别。参见：https://www.lexaloffle.com/bbs/?tid=32130。

要设置哪些键盘按键触发摇杆按键，使用 `KEYCONFIG` 。

## 1.9 屏幕截图和 GIF

卡带运行的时候，使用：

> CTRL-6 保存屏幕截图到桌面  
> CTRL-7 捕捉卡带标签图像  
> CTRL-8 开始录制视频  
> CTRL-9 保存 GIF 视频到桌面（默认 8 秒）

你可以随时保存视频（视频永远都在录制）；CTRL-8 只是重置视频的起始点。录制时间要长于 8 秒，使用 `CONFIG` 命令（最大值：120）：

``````
CONFIG GIF_LEN 60
``````

如果你想要录制每次都重置（以创建不重叠的序列），使用：

``````
CONFIG GIF_RESET_MODE 1
``````

gif 格式无法精确到 30fps ，所以 PICO-8 转而使用最接近的值：33.3fps。

如果你保存到桌面时出现了问题，请尝试在 `config.txt` 中配置别的桌面路径。

## 1.10 分享卡带

有三种方式能分享用 PICO-8 制作的卡带：

1. 直接与其他 PICO-8 用户分享 `.p8` 或 `.p8.png` 文件

   输入 `FOLDER` 以在你的宿主操作系统中打开当前文件夹

2. 把卡带发送到 Lexaloffe BBS 以获得可在网页游玩的版本

   http://www.lexaloffle.com/pico-8.php?page=submit

3. 导出卡带到独立的 html/js 或者原生二进制播放器（参阅“导出工具”小节以得到更多细节）

## 1.11 SPLORE

`SPLORE` 是一个内置实用工具，用来浏览并组织本地和 BBS（在线）卡带。输入 `SPLORE` [enter] 启动，或者用`-splore` 开关启动 PICO-8 。

你可以全程使用手柄来控制 `SPLORE` ：

> LEFT 和 RIGHT 切换卡带列表  
> UP 和 DOWN 选择每个列表的项目  
> X，O 或 MENU 启动卡带

在卡带内，按 MENU 收藏一个卡带或退回 `SPLORE` 。如果你使用键盘，在卡带列表视图中选中卡带后，可以按 F 收藏卡带。

查看 BBS 卡带列表时，使用最顶部的菜单项重新下载卡带列表。如果你处于离线状态，你所查看的就是最后一次下载的卡带列表，并且你依然可以游玩你已经查看过的卡带。

一旦 BBS 卡带被运行过一次，或者有出现在 `SPLORE` 的列表里，它们就会被自动获取并永久缓存。通常没有必要手动下载并存储这些卡带。有一个例外，那就是会加载（`load()`）其它卡带的卡带；里面的每张卡带在第一次加载时都需要互联网连接。

如果你在没有互联网访问的机器上安装了 PICO-8 ，你也可以使用 `INSTALL_GAMES` 添加一小部分预装的 BBS 卡带到 `/games`。你也可以在本地文件页面中查看所有缓存过的卡带（按下载时间排序）。

`SPLORE` 搜索页面可以只使用手柄来操作；按 LEFT 和 RIGHT 移动光标，按 UP 和 DOWN 循环选择字母、数字和一些符号。

如要查看你的在线 BBS 收藏卡带，首先将你的收藏设置为公开（在账号设置中），随后在 `SPLORE` 中搜索 `fav:username` 。

# 2 编辑工具

按 ESC 切换控制台和编辑器。  
编辑模式下，点击右上角的选项卡可以切换，也可以按 ALT+LEFT/RIGHT 切换。

## 2.1 代码编辑器

> 按住 Shift 以选择（或者点击并拖动鼠标）  
> CTRL-X，C，V 分别是剪切，复制和粘贴选中代码  
> CTRL-Z，Y 分别是撤销，重做  
> CTRL-F 在当前选项卡中查找文本  
> CTRL-G 重复上一次搜索  
> CTRL-L 跳转到行号  
> CTRL-UP，DOWN 分别是跳转到起始和末尾  
> ALT-UP，DOWN 分别是导航到上一个和下一个函数  
> CTRL-LEFT，RIGHT 按单词跳转  
> CTRL-W，E 分别是跳转到当前行的行首和行尾  
> CTRL-D 重复当前行  
> TAB 向右缩进选择项（按住 Shift 向左缩进）  
> CTRL-B 注释 / 取消注释选中块  
> CTRL-U 获取光标下的关键字的帮助信息

要输入代表按钮的特殊字符（以及其他字形），使用 SHIFT-L，R，U，D，O，X 。还有 3 种额外的字体输入模式可以切换：

> CTRL-J 平假名  // 输入等价的罗马音 (ka, ki, ku..)  
> CTRL-K 片假名  // + shift-0..9 获取额外符号  
> CTRL-P 小字体  // 按住 shift 输入标准字体

> [!NOTE]
>
> 默认情况下，小字体字符在复制 / 粘贴时是以 Unicode 斜体字符编码的，大小写 ASCII 字符都粘贴为正常的 PICO-8 字符。要以大写 ASCII 形式复制 / 粘贴小字体字符，请确保小字体模式（CTRL-P）处于启用状态。

### 代码选项卡

点击顶部的 [+] 按钮添加新选项卡。左键点击或使用 CTRL-TAB，SHIFT-CTRL-TAB 切换选项卡。要移除最后一个选项卡，删除所有内容并切换到别的选项卡（CTRL-A，DEL，CTRL-TAB）。

运行卡带的时候，所有的选项卡会按顺序拼接，生成一个单一程序。

### 代码限制

代码的 Token 数显示在右下角。一个程序最大可以有 8192 个 Token。每一个 Token 是一个单词（例如变量名）或者运算符。每个括号对和字符串算作 1 个 Token。逗号，句号，`LOCAL` ，分号，`END` 和注释不算。

右键点击可以切换其他统计信息（字符数，压缩大小）。如果达到了某个限制，编辑器会闪烁警告灯。这可以用右键来禁用。

## 2.2 精灵编辑器

精灵编辑器既可以用于精灵方面的编辑，也可以用于任意的像素图像编辑。屏幕底部的精灵导航器提供了对精灵表（Sprite sheet） 的 8x8 精灵视图。但也可以使用自由形态工具（抓手，选择）来处理更大或大小古怪的区域。

### 绘图工具

在精灵上点击并拖动以绘制像素，或者使用右键来选择指针底下的颜色。

所有操作只应用于可见区域，或是存在的选区。

按住 CTRL 来搜索并替换颜色。

### 图章工具

点击可以把复制缓冲区里的图像盖上去。按住 CTRL 把颜色 0（黑色）视作透明。

### 选择工具（快捷键：SHIFT 或 S）

点击并拖动来创建矩形选区。要删除选区，按 ENTER 或点击别处。

如果不存在像素级选区，大部分操作就应用到精灵级选区，或者可见视图。要选择精灵，在精灵导航器中按住 Shift 并拖动。要选择精灵表，按下 CTRL-A（重复多次可以切换是否选择与地图数据共享的下半部分）。

### 抓手工具（快捷键：SPACE）

点击并拖动以在精灵表上四处移动。

### 填充工具

用当前颜色填充。这仅应用于当前选区，没有选区时则是可见区域。

### 形状工具

点击工具按钮以循环切换：椭圆，矩形，直线选项。

按住 CTRL 可以得到实心椭圆或矩形。  
按住 SHIFT 可以固定为圆形，正方形，或者低整数比的直线。

### 额外快捷键

CTRL-Z：撤销  
CTRL-C/X：复制 / 剪切选择的区域或者选择的精灵  
CTRL-V：粘贴到当前精灵位置  
Q/A，W/Z：切换到上一个 / 下一个精灵  
1，2：切换到上一种 / 下一种颜色  
TAB：切换全屏视图  
鼠标滚轮或者 < 和 > 来放大缩小（全屏下居中）  
CTRL-H：切换十六进制视图（以十六进制显示精灵索引）  
CTRL-G：切换放大时显示的黑色网格线

### 对选择区域或选择精灵的操作

F：水平翻转精灵  
V：垂直翻转精灵  
R：旋转（需要一个正方形选区）  
方向键移动（如果是选择精灵，则会循环移动）  
DEL/BACKSPACE：清除选区内图像

### 精灵标志

8 个有色圆圈是当前精灵的精灵标志。虽然标志没有特定含义，但是可以用 `FGET()` / `FSET()` 函数来访问。它们从索引 0 开始，从左到右检索。

查阅 `FSET()` 获取更多信息。

### 加载 .png 文件到精灵表

要把任意大小的 png 文件加载到精灵表，首先选择作为加载目的地左上角的精灵，然后输入 `IMPORT IMAGE_FILE.PNG` 或者拖放图像文件到 PICO-8 窗口。无论哪种方式，图像的颜色都会贴近到当前的显示调色板。

## 2.3 地图编辑器

PICO-8 地图是一块由 8 位数值组成的 128x32（如果用到了共享空间，那就是 128x64 ）。编辑器内显示的每个数值都是对精灵的引用（0..255），但是你当然也可以用这些数据表示你想要的任何东西。

> [!WARNING]
>
> 精灵表的另一半（Bank 2 和 3），和地图的下半部分共享相同的卡带空间。如何使用这些数据取决于你，但请注意在精灵表的另一半绘图会破坏地图的数据，反之也是。

工具与精灵编辑模式下的比较相似。选择一个精灵，点击并拖动以在地图上填入数值。

要绘制多个精灵，用 Shift+拖动 从精灵导航器中选择。要复制一块数值，用选择工具复制，随后用图章工具来粘贴。要四处导览地图，使用抓手工具或者按住 Space。用 Q，W 来切换上一个/下一个精灵。用鼠标滚轮或者 < 和 > 来放大缩小（全屏下居中）。用 CTRL-H 切换十六进制视图（用十六进制显示瓦片（tile）数值和精灵索引）。

在精灵表中移动精灵而不会破坏地图中对精灵的引用会有点棘手，但是是可行的：

1. 按 ENTER 删除地图选区

2. 选择你想要移动的精灵（保持在地图视图），按下 CTRL-X

3. 选择要影响的地图区域（默认是地图的上半部分）

   // 按下 CTRL-A 两次选择完整的地图，包括共享内存部分

4. 选择目标精灵（依然保持在地图视图），按下 CTRL-V

> [!NOTE]
>
> 这项操作虽然会同时修改地图和精灵编辑器的撤销历史，但是 PICO-8 会尽量使它们保持同步。否则，移动地图精灵导致的改动可以通过在精灵编辑器中手动撤销来取消。

## 2.4 SFX 编辑器

卡带内有 64 个 SFX（“声音效果”），既用于音效也用于音乐。

每个 SFX 有 32 个音符，每个音符有：

频率（C0..C5）  
乐器（0..7）  
音量（0..7）  
效果（0..7）

每个 SFX 还有这些属性：

回放速度（SPD）：每个音符演奏使用的“时间刻”数量。  
// 这意味着 1 是最快的，3 是 3 倍的慢，以此类推。

循环（LOOP）头和尾：这是循环折回和循环结尾的音符索引  
// 当起始索引索引大于等于结束索引时，循环被关闭。

只用到第一个的两位数（第二个是 0）的时候，意思就是演奏的音符数量。对音效来说，正常是不需要的（你可以把剩余的音符留空），其适用于控制音乐回放。

编辑 / 查看 SFX 有两种模式：音高模式（更适合音效）和 Tracker 模式（更适合音乐）。模式可以用左上角的按钮切换，或者用 TAB 切换。

### 音高模式

在音高区域点击并拖动来设置每个音符的频率，音符使用的是当前选择的乐器（由颜色指示）。

按住 Shift 只应用于选择的乐器的音符。  
按住 CTRL 使输入的音符吸附到 C 小调五声音阶。  
右键获取指定音符的乐器

### Tracker 模式

每个音符显示：频率 八度 乐器 音量 效果  
要输入一个音符，使用 q2w3er5t6y7ui zsxdcvgbhnjm（类似钢琴的布局）  
输入音符时，按住 Shift 进行移调，-1 八度 .. +1 八度  
新音符会使用选择的乐器 / 效果数值  
要删除一个音符，使用 Backspace 或设置音量为 0

点击然后 Shift-点击 来选择一个范围，可以复制（CTRL-C）和粘贴（CTRL-V）。注意只有选中的属性会被复制。双击选择单个音符的所有属性。

导航：

PAGEUP/DOWN 或 CTRL-UP/DOWN 向上或向下跳过 4 个音符  
HOME/END 跳转到第一个或最后一个音符  
CTRL-LEFT/RIGHT 在不同的列之间跳转

### 两种模式的控制

\- \+ 切换当前 SFX  
< > 切换速度。SPACE 播放 / 停止  
SHIFT-SPACE 从当前的 SFX quarter 开头开始播放（8 个音符一组）  
A 释放循环采样  
左键或右键来增加 / 减少 SPD 或 LOOP 数值  
// 点击时按住 Shift 来增加 / 减少 4  
// 还有一种方法，点击并向左/向右或向上/向下拖动  
Shift-点击 一个乐器，效果或音量以将其应用到所有音符

### 效果

| 数值 | 效果                      | 注释                          |
| ---- | ------------------------- | ----------------------------- |
| 0    | 无（none）                |                               |
| 1    | 滑音（slide）             | 音高和音量滑向下一个音符      |
| 2    | 颤音（vibrato）           | 在一个四分音符内快速变化音高  |
| 3    | 降调（drop）              | 频率快速下降到很低的数值      |
| 4    | 淡入（fade in）           | 音量从 0 往上逐渐变高         |
| 5    | 淡出（fade out）          | 音量往下逐渐变为 0            |
| 6    | 快速琶音（arpeggio fast） | 迭代 4 个音符的一组，速度为 4 |
| 7    | 慢速琶音（arpeggio slow） | 迭代 4 个音符的一组，速度为 8 |

如果 SFX 速度小于等于 8，琶音速度减半到 2，4。

### 滤镜

每个 SFX 有 5 个滤镜开关，可以在 Tracker 模式下访问：

| 滤镜     | 描述                                                 |
| -------- | ---------------------------------------------------- |
| NOIZ     | 生成纯白噪音（仅适用于乐器 6）                       |
| BUZZ     | 对波形进行多种修改，使其听起来更有滋滋的感觉         |
| DETUNE-1 | 对第二个音做失谐处理，创造一种类似镶边的效果         |
| DETUNE-2 | 对第二个音做各种调音处理，大部分是调高或调低一个八度 |
| REVERB   | 应用一个带有 2 或 4 个时间刻的延音的回声效果         |
| DAMPEN   | 两种不同等级下的低通滤波器                           |

当 BUZZ 和乐器 6 一起使用，NOIZ 处于关闭状态时，程序会生成纯褐噪音。

## 2.5 音乐编辑器

PICO-8 中的音乐是由一系列样式（Pattern）控制。每个样式是一个 4 个数值的列表，其指出哪个 SFX 会在那个通道上播放。

### 流控制

回放流可以使用右上角的 3 个按钮来控制。

当一个样式播放结束后，下一个样式就会播放，除非：

- 没有可以播放的数据（音乐停止）
- 在这个样式上设置了 `STOP` 命令（第三个按钮）
- 设置了一个 `LOOP BACK` 命令（第二个按钮），在这种情况下，音乐播放器会往回寻找设置了 `LOOP START` 命令（第一个按钮）的样式并播放，如果找不到就回到样式 0

当一个样式有不同速度的 SFX，样式仅当最左边的非循环通道播放结束后才结束播放。这可以用来建立双节拍鼓点或不寻常的复合节奏。

对于类似 3/4 的拍号，跳转到下一个样式前应播放小于 32 行的音符，SFX 的长度可以通过只设置第一个循环点，第二个循环点保持为 0 来设置。这会在 SFX 编辑器中显示 `LEN`（表示“长度”）而不是 `LOOP`。

### 复制和粘贴音乐

要选择一系列样式：在样式导航器中点击一次第一个样式，然后 Shift-点击 最后一个样式。选择的样式可以用 CTRL-C 和 CTRL-V 来复制粘贴。粘贴到其他卡带时，如果 SFX 不存在，样式指向的 SFX 也会被粘贴（索引可能不同）。

### SFX 乐器

除了 8 个内置乐器，可以使用开头的 8 个 SFX 来定义自定义乐器。使用乐器右边的切换按钮来选择一个索引，这个索引会在乐器通道中显示绿色而不是粉色。

演奏一个 SFX 乐器音符的时候，本质上就是触发那个 SFX，但是会修改音符的属性：

音高相对于 C2 相加  
音量相乘  
效果会应用在 SFX 乐器效果之上  
任何 SFX 乐器上的滤镜都会对这个音符启用

例如，我们可以实现一个简单的震音效果，方法是在 SFX 0 定义一个乐器，其会在音量 5 和 2 之间快速交替。当使用这个乐器演奏一个音符时，音量可以和往常一样进一步修改（使用音量通道或使用淡入淡出效果）。通过这种方式可以使用 SFX 乐器控制音量，音高和音色的精细变化。

SFX 乐器只在音高改变，或者前一个音符的音量为 0 的时候重新触发。这适用于随时间推移缓慢变化的乐器。例如：逐渐淡出的钟声。要避免这种行为，触发音符时可以使用效果 3（正常是“降调”）。所有其他的效果数值在触发 SFX 乐器时含义与往常相同。

### 波形乐器

波形乐器和 SFX 乐器的运作方式相同，但是其包含了一个自定义的 64 字节循环波形。点击 SFX 编辑器里的波形开关按钮以使用 SFX 0..7 作为波形乐器。在这种模式下，采样可以用鼠标绘制。

### 音阶吸附

在音高模式下绘制音符时，按住 CTRL 可以吸附到当前定义的音阶。默认使用的是 C 小调五声音阶，可以使用音阶编辑器模式自定义音阶。右下角有个小小的键盘图标可以切换这个模式。有 2 个转调按钮，1 个反转按钮和 3 个音阶预设按钮：

> Dim  减 7 音阶 - 反转得到全半音阶  
> Maj  大调音阶 - 反转得到五声音阶  
> Who  全音阶 - 反转得到 ... 其他的全音阶

改变音阶并不会影响当前的 SFX，仅当按住 CTRL 绘制新音符的时候影响，此时会应用新的音阶。

# 3 导入工具 / 导出工具

`EXPORT` 命令用于生成 png，wav 文件，独立的 html 和原生二进制卡带应用程序。输出格式从文件扩展名推断（例如 .png）。

你可以随意分发和使用导出的卡带和数据，只要你获得卡带作者和贡献者的许可。

- **精灵列表 / 标签（.png）**

``````
> IMPORT BLAH.PNG   -- EXPECTS 128X128 PNG AND COLOUR-FITS TO THE PICO-8 PALETTE
> EXPORT BLAH.PNG   -- USE THE "FOLDER" COMMAND TO LOCATE THE EXPORTED PNG
``````

导入的时候，`-x` 和 `-y` 开关可以用来以像素为单位指定目标位置；`-s` 可以用来缩小图像（3 的意思是从 384x384 缩小到 128x128）：

``````
> IMPORT BLAH.PNG -X 16 -Y 16 -S 3
``````

和 `IMPORT` 和 `EXPORT` 一起使用`-l` 开关则可以读写卡带的标签：

``````
> IMPORT -L BLAH.PNG
``````

> [!NOTE]
>
> 导入精灵表或标签时，调色板的颜色会贴合到当前绘制状态的调色板。

- **SFX 和音乐（.wav）**

从当前样式导出音乐（当编辑器模式是音乐），或者当前 SFX：

``````
> EXPORT FOO.WAV  
``````

导出所有的 SFX 为 foo0.wav，foo1.wav .. foo63.wav：

``````
> EXPORT FOO%D.WAV
``````

- **地图和代码**

卡带的地图或源代码可以导出为单一图片，叫做 `.map.png` 或 `.lua.png`：

``````
> EXPORT FOO.MAP.PNG
> EXPORT FOO.LUA.PNG
``````

地图图像是 1024X512（128x32 的 8x8 精灵）。Lua 图片的大小会设置为合适大小，但是每一行固定（同时被裁剪）为 192 像素宽。

- **卡带（.p8，.p8.png，.p8.rom）**

使用 `EXPORT` 保存卡带和使用 `SAVE` 差不多，但并不会改变当前编辑的卡带。例如，这可以用于以 `.p8.png` 格式保存一份副本用于分发，不会意外地在这份副本，而不是原始的 `.p8` 文件上做改动。

`EXPORT` 还可以用于从命令行进行卡带文件格式转换。例如，在 Linux shell 上：

``````shell
> pico8 foo.p8 -export foo.p8.png
``````

## 3.1 Web 应用程序（.html）

生成一个独立的 html 播放器（mygame.html，mygame.js）：

``````
> EXPORT MYGAME.HTML
``````

或者只要 `.js` 文件：

``````
> EXPORT MYGAME.JS
``````

使用 `-f` 把文件写到一个叫 `mygame_html` 的文件夹，使用 `index.html` 而不是 `mygame.html`：

``````
> EXPORT -F MYGAME.HTML
``````

可选的，可以用 `-p` 开关提供一个自定义的 html 模版：

``````
> EXPORT MYGAME.HTML -P ONE_BUTTON
``````

这会使用文件 `{application data}/pico-8/plates/one_button.html` 作为 html 外壳，替换一个特殊字符串 `##js_file##` 为 `.js` 文件名。可选的，替换字符串 `##label_file##` 为卡带标签图片的 Data URL。

使用 `-w` 导出为 `.wasm` \+ `.js` ：

``````
> EXPORT -W MYGAME.HTML
``````

> [!NOTE]
>
> 导出为 `.wasm` 的时候，页面必须由一个 Web 服务器提供，而不是直接从本地文件系统中用浏览器打开。对大部分用途而言，默认的 `.js` 导出没啥问题，但是 `.wasm` 稍微小一点也快一点。

## 3.2 二进制应用程序（.bin）

给 Windows，Linux（64 位），Mac 和树莓派生成独立可执行程序：

``````
> EXPORT MYGAME.BIN
``````

默认情况下，卡带标签用作图标，不透明。要从精灵表中指定一个图标，使用 `-i` 。可选的，使用 `-s` 并 / 或使用 `-c` 控制大小和透明。

> -I N  图标索引为 N，默认透明色是 0（黑色）  
> -S N  大小为 NxN 的精灵。大小 3 会产生 24x24 大小的图标  
> -C N  把颜色 N 当作透明色。使用 16 表示不透明

例如，使用精灵表中索引 32 开始的 2x2 精灵，使用颜色 12 作为透明色：

``````
> EXPORT -I 32 -S 2 -C 12 MYGAME.BIN
``````

要在输出文件夹和压缩档案中包含额外的文件，使用 `-E` 开关：

``````
> EXPORT -E README.TXT MYGAME.BIN
``````

> [!NOTE]
>
> Windows 文件系统不支持创建 Linux 或 Mac 可执行文件所需的文件元数据。PICO-8 通过导出保留文件属性的 zip 文件来解决这个问题。因此，建议把输出的 zip 文件原样分发，以保证其他操作系统的用户能运行。否则，下载了二进制文件的 Linux 用户可能需要对文件使用 `chmod +x mygame` 才能运行，Mac 用户需要使用 `chmod +x mygame.app/Contents/MacOS/mygame`。

## 3.3 上传到 itch.io

如果你想要把你导出的卡带上传到 itch.io，生成可游玩的 html：

1. 在 PICO-8 内：`EXPORT -F MYGAME.HTML`

2. 在你的 itch 创作中心创建一个新项目

3. 把文件夹打包为 zip 并上传（设置 “这个文件会在浏览器中游玩”）

4. 设置嵌入到页面，大小为 750px x 680px

5. 勾选“移动设备支持”（默认方向）以及“页面加载时自动启动”

   // 不需要全屏按钮，因为默认的 PICO-8 模版已经有自己的全屏按钮了

6. 设置背景颜色（BG2）为暗一点的颜色（例如 `#232323`），文本为亮一点的颜色（`#cccccc`）

## 3.4 导出多个卡带

生成独立的 html 或原生二进制播放器时，多达 16 个卡带可以传递给 `EXPORT` 以打包在一起。

``````
> EXPORT MYGAME.HTML DAT1.P8 DAT2.P8 GAME2.P8
``````

运行时，附加的卡带可以像本地文件一样访问：

``````lua
RELOAD(0,0,0X2000, "DAT1.P8") -- 从 DAT1.P8 读取精灵表
LOAD("GAME2.P8")              -- 加载并运行另一个卡带
``````

> [!NOTE]
>
> 导出的卡带不能加载并运行 BBS 卡带，例如使用 `LOAD("#FOO")`。

## 3.5 从宿主操作系统运行 EXPORT

运行 PICO-8 时，使用 `-export` 开关可以以无头模式启动导出工具。文件路径相对于当前目录，而不是 PICO-8 的文件系统。

`EXPORT` 命令的参数以一个单一（小写）字符串传入：

``````shell
pico8 mygame.p8 -export "-i 32 -s 2 -c 12 mygame.bin dat0.p8 dat1.p8"
``````

# 4 Lua 语法入门

PICO-8 程序使用 Lua 语法编写，但是不使用 Lua 标准库。以下是对 Lua 精华语法的简单总结。

要获取更多细节，或者查询正规 Lua 语法，参阅 www.lua.org。

## 注释

``````lua
-- 使用像这样的两个横杠写一条注释
--[[ 多行
注释 ]]
``````

## 数据类型和赋值

Lua 里的数据类型有数字（number），字符串（string），布尔值（boolean）和表（table）：

``````lua
NUM = 12/100
S = "这是一个字符串"
B = FALSE
T = {1,2,3}
``````

PICO-8 里的数字都是 16:16 的定点数。数值范围从 `-32768.0` 到 `32767.99999`。

可以使用十六进制记号，带有可选的分数部分：

``````lua
?0x11        -- 17
?0x11.4000   -- 17.25
``````

用十进制书写的数字会四舍五入至最近的定点数值。要查看 32 位十六进制的表示结果，使用 `PRINT(TOSTR(VAL,TRUE))` ：

``````lua
?TOSTR(-32768,TRUE)      -- 0x8000.0000
?TOSTR(32767.99999,TRUE) -- 0X7FFF.FFFF
``````

如果是正数，除以 0 的结果是 `0x7fff.ffff`；如果是负数，除以 0 的结果是 `-0x7ffff.ffff`。

## 条件分支

``````lua
IF NOT B THEN
  PRINT("B 是 FALSE")
ELSE
  PRINT("B 不是 FALSE")
END
``````

带 `ELSEIF`

``````lua
IF X == 0 THEN
  PRINT("X 是 0")
ELSEIF X < 0 THEN
  PRINT("X 是负数")
ELSE
  PRINT("X 是正数")
END
``````

``````lua
IF (4 == 4) THEN PRINT("相等") END
IF (4 ~= 3) THEN PRINT("不相等") END
IF (4 <= 4) THEN PRINT("小于或等于") END
IF (4 > 3) THEN PRINT("大于") END
``````

## 循环

循环区间是闭区间：

``````lua
FOR X=1,5 DO
  PRINT(X)
END
-- 打印 1,2,3,4,5
``````

``````lua
X = 1
WHILE(X <= 5) DO
  PRINT(X)
  X = X + 1
END
``````

``````lua
FOR X=1,10,3 DO PRINT(X) END   -- 1,4,7,10
``````

``````lua
FOR X=5,1,-2 DO PRINT(X) END  -- 5,3,1
``````

## 函数和局部变量

声明为 `LOCAL` 的变量，作用域是包含它们的代码块（例如，在 `FUNCTION` 里面，一个 `FOR` 循环，或者 `IF THEN END` 表达式）。

``````lua
Y=0
FUNCTION PLUSONE(X)
  LOCAL Y = X+1
  RETURN Y
END
PRINT(PLUSONE(2)) -- 3
PRINT(Y)          -- 0
``````

## 表

在 Lua 中，表是键值对的集合，键和值的类型都可以混合。用整数检索，表可以用作数组。

``````lua
A={} -- 创建一个空表
A[1] = "BLAH"
A[2] = 42
A["FOO"] = {1,2,3}
``````

数组默认使用以 1 开始的索引：

``````lua
> A = {11,12,13,14}
> PRINT(A[2]) -- 12
``````

但如果你更喜欢以 0 开始的数组，只要在 0 号槽位写入东西：

``````lua
> A = {[0]=10,11,12,13,14}
``````

但是使用以 1 开始的索引的表更特殊。这种数组的长度可以用 `#` 运算符得到，PICO-8 用这样的数组实现了 `ADD` ，`DEL` ，`DELI` ，`ALL` 和 `FOREACH` 函数。

``````lua
> PRINT(#A)   -- 4
> ADD(A, 15)
> PRINT(#A)   -- 5
``````

字符串索引可以用点记号书写。

``````lua
PLAYER = {}
PLAYER.X = 2 -- 等价于 PLAYER["X"]
PLAYER.Y = 3
``````

若要获取更多细节，参阅“表函数”小节。

## PICO-8 简写语法

PICO-8 还允许用一些非标准，简短的方法来书写常见模式。

1. `IF THEN END` 表达式，和 `WHILE THEN END` 可以像这样写在一行上：

   ``````lua
   IF (NOT B) I=1 J=2
   ``````

   这等价于：

   ``````lua
   IF NOT B THEN I=1 J=2 END
   ``````

   注意简写条件周围的括号是必需的。

2. 赋值运算符

   如果整个表达式在一行上，可以使用简写的赋值运算符。往任意二元运算符后面添加一个 `=` 就能构建，包括算术运算（`+=`，`-=` ..），位运算（`&=`，`|=` ..）或字符串拼接运算符（`..=`）

   ``````lua
   A += 2   -- 等价于: A = A + 2
   ``````

   // 注意左值出现了两次，所以对于 `TBL[FN()]+=1` ，`FN()` 会被调用两次。

3. `!=` 运算符

   并非简写，但是 PICO-8 也接受用 `!=` 取代 `~=` 来表示“不相等”

   ``````lua
   PRINT(1 != 2) -- TRUE
   PRINT("FOO" == "FOO") -- TRUE (字符串驻留)
   ``````

# 5 PICO-8 程序结构

一个 PICO-8程序运行的时候，选项卡里的所有代码都会被拼接起来（从左到右）并执行。虽然手动提供你自己的主循环是可行的，但是典型的 PICO-8 程序会使用 3 个特殊的函数，如果作者有定义这些函数，函数就会在程序执行期间被调用：

`_UPDATE()` -- 以 30fps 的频率，每次更新时调用  
`_DRAW()` -- 绘制每个可见帧时会调用一次  
`_INIT()` -- 程序启动时调用一次

使用以上三个函数的简单程序看上去大概是这样的：

``````lua
FUNCTION _INIT()
  -- 永远以白色开始
  COL = 7
END
 
FUNCTION _UPDATE()
  -- 按 X 得到一个随机色
  IF (BTNP(5)) COL = 8 + RND(8)
END
 
FUNCTION _DRAW()
  CLS(1)
  CIRCFILL(64,64,32,COL)
END
``````

`_DRAW()` 正常以 30fps 的频率调用，但是如果该函数无法及时执行完成，PICO-8 将会尝试以 15fps 的帧率运行，每个可见帧会调用两次 `_UPDATE()` 来补偿。

## 以 60fps 的帧率运行 PICO-8

`_UPDATE60()`

当定义了 `_UPDATE60()` 而不是 `_UPDATE()` 的时候，PICO-8 会运行在 60fps 模式：

\- `_UPDATE60()` 和 `_DRAW()` 都会以 60fps 的频率调用  
\- 降至 30fps 之前，每帧的 PICO-8 CPU 是一半空闲的

注意不是所有的宿主机器都支持运行在 60fps 。老机器以及 / 或 Web 版本可能会请求 PICO-8 运行在 30fps（或 15fps），即使 PICO-8 CPU 并没有超出负荷。在这种情况下，用同样的方法，每次 `_DRAW` 调用时都会调用多次 `_UPDATE60` 。

## #INCLUDE

源代码可以在卡带启动时（但不是在运行时）注入程序，使用 `#INCLUDE FILENAME` ，其中 `FILENAME` 要么是纯文本文件（包含 Lua 代码），要么是另一个卡带的一个选项卡，要么是另一个卡带的所有选项卡：

``````lua
#INCLUDE SOMECODE.LUA
#INCLUDE ONETAB.P8:1
#INCLUDE ALLTABS.P8
``````

卡带运行的时候，每个被包含文件的内容就好像被粘贴到编辑器中，`#INCLUDE`那一行的位置一样。

\- 文件名相对于当前的卡带（所以要先保存）  
\- 包含并不是递归执行的  
\- 正常字符计数和 Token 限制同样适用

当卡带保存为 `.P8.PNG` ，或者导出为二进制文件，任何包含的文件会被扁平化，和卡带一同保存，这样就不存在外部依赖了。

`#INCLUDE` 可以用在像是：

\- 卡带之间共享代码（库或者多卡带共用代码）  
\- 使用外部代码编辑器，且不需要直接编辑 `.p8` 文件  
\- 把卡带当作数据文件，其会加载到 PICO-8 编辑工具以进行修改  
\- 加载并存储由外部（并非 PICO-8）工具生成的数据

## PICO-8 中需要留意的地方

常见的要注意的地方有：

\- 精灵表的下半部分和地图的下半部分占据同一块内存。// 如果你不清楚这是怎么一回事，最好只使用其中一部分  
\- PICO-8 数字的精度和范围有限；数字之间的最小差距大约是 `0.00002`（`0x0.0001`），范围从 `-32768` 到大约 `32767.99999`（`0x7ffff.ffff`）// 如果你每一帧给一个计数器加 1，大约 18 分钟后它就会溢出！  
\- Lua 数组默认从 1 开始，而不是从 0 开始，`FOREACH` 从 `TBL[1]` 开始，而不是从 `TBL[0]` 开始  
\- `COS()` 和 `SIN()` 接受 0..1 而不是 0..PI*2 ，并且 `SIN()` 执行结果的符号是反的（即正数结果实际返回负数，反之也是）

## CPU

虽然 PICO-8 并没有一个清晰定义的 CPU，但是存在一个速度为 8MHz 的虚拟 CPU，其中每个 Lua 虚拟机指令消耗大约 2 个周期。内置操作像是绘制精灵也会有 CPU 开销。这意味着在一台有高性能 CPU 的宿主机上制作的 PICO-8 卡带依然能保证在更为缓慢的机器上运行（大致）良好，在手机 / 在 Web 上运行时不会消耗太多电池。

在卡带运行的时候要查看 CPU 负载，请按 CTRL-P 切换出 CPU 量表，或者在每帧的结尾打印 `STAT(1)` 的结果。

# 6 API 参考

PICO-8 基于 Lua 编程语言构建，但是并不包括 Lua 标准库。  
取而代之的是，PICO-8 提供一个小型的 API 以保持极简化设计和有限的屏幕空间。如果需要一个使用大部分 API 函数的示例程序，参阅 `/DEMOS/API.P8`

函数将以下面的形式表示：

``````
FUNCTION_NAME(PARAMETER, [OPTIONAL_PARAMETER])
``````

> [!NOTE]
>
> PICO-8 并没有分大小写字符 -- 如果你直接编辑一个 `.p8` 或 `.lua` 文件，函数名应当均为小写。

## 6.1 系统

从命令行调用的系统函数可以省略一般要有的括号和字符串双引号。例如，不用写 `LOAD("BLAH.P8")` ，写成下面这样也是可行的：

``````
>LOAD BLAH.P8
``````

### LOAD(FILENAME, [BREADCRUMB], [PARAM_STR])
### SAVE(FILENAME)

加载或保存一个卡带

当运行中的卡带发起加载时，加载完成的卡带会携带着参数字符串 `PARAM_STR`（可以用 `STAT(6)` 访问）立即运行，一条叫做 `BREADCRUMB` 的项目会插入进菜单中，选择该项后，用户会返回到先前的卡带。

以 `#` 开头的文件名会被认为是 BBS 卡带 ID，其会立即下载并运行：

``````lua
> LOAD("#MYGAME_LEVEL2", "BACK TO MAP", "LIVES="..LIVES)
``````

如果 ID 是卡带的父帖，或者没有指定修订号，那么就会获取最新版本。BBS 卡带可以从其他 BBS 卡带或者本地卡带加载，但是不能从导出卡带加载。

### FOLDER

在宿主操作系统中打开卡带文件夹。

### LS([DIRECTORY])

列出给定目录（文件夹）下的 `.p8` 和 `.p8.png` 文件，相对于当前目录。目录项会以斜杠结尾（例如 `foo/`）。

当从运行中的卡带中调用时，`LS` 只能在本地使用并返回含有结果的表。  
当从 BBS 卡带中调用时，`LS` 返回 `nil` 。

目录只能在 PICO-8 的虚拟磁盘上解析；在根目录调用 `LS("..")` 会解析为根目录。

### RUN([PARAM_STR])

从程序的起始位置开始运行。

`RUN()` 可以在运行中的程序内部调用以重置程序。

提供 `PARAM_STR` 的时候，可以在运行时用 `STAT(6)` 访问。

### STOP([MESSAGE])

停止卡带。可选的，打印一条信息。

### RESUME

恢复程序运行。可简写为 `R` 。

在命令行使用一个单一的 `.` 可以前进一帧。这会进入逐帧模式，这个模式能用 `stat(110)` 读取到。逐帧模式激活后，输入一条空命令（通过按下 enter）可以前进一帧。

### ASSERT(CONDITION, [MESSAGE])

如果 `CONDITION` 是 `false` ，程序停止，如果提供了 `MESSAGE` ，程序还会将其打印出来。调试卡带的时候比较有用，可以用 `ASSERT()` 对你确信是 `true` 的东西下断言。

``````lua
ASSERT(ADDR >= 0 AND ADDR <= 0x7FFF, "OUT OF RANGE")
POKE(ADDR, 42) -- 内存地址没问题，这是肯定的！
``````

### REBOOT

重启机器，新建一个项目的时候比较有用。

### RESET()

重置 RAM 中 `0x5f00` .. `0x5f7f` 范围的数据到其默认值。这里面包括了调色板，相机位置，裁剪和填充图案。如果你因为当前绘制状态让人无法识读文字，在命令行提示下不知所措，你就尝试输入 `RESET` ！运行中的程序也可以调用它。

### INFO()

打印一些关于卡带的信息：代码大小，Token 数，压缩大小

还会显示：

`UNSAVED CHANGES` - 内存中的卡带与磁盘上的不一致  
`EXTERNAL CHANGES` - 卡带加载后，磁盘上的卡带发生了改动（例如，使用单独的文本编辑器编辑了程序）

### FLIP()

将后台缓冲区翻转到屏幕上并等待下一帧。如果定义了 `_DRAW()` 或 `_UPDATE()` 回调，就不需要调用它，因为翻转会自动进行。但是如果使用了自定义的主循环，正常就需要调用 `FLIP` 了：

``````lua
::_::
CLS()
FOR I=1,100 DO
  A=I/50 - T()
  X=64+COS(A)*I
  Y=64+SIN(A)*I
  CIRCFILL(X,Y,1,8+(I/4)%8)
END
FLIP()GOTO _
``````

如果你的程序在下一帧到来之前没有调用 `FLIP` ，并且也没有进行 `_DRAW()` 回调，当前后台缓冲区的内容就会被复制到屏幕上。

### PRINTH(STR, [FILENAME], [OVERWRITE], [SAVE_TO_DESKTOP])

打印一个字符串到宿主操作系统的控制台，用于调试。

如果设置了文件名，就会在宿主操作系统上把字符串追加到一个文件里（默认在当前目录 -- 用 `FOLDER` 查看）

设置 `OVERWRITE` 为 `true` 会导致文件被覆盖而不是被追加。

设置 `SAVE_TO_DESKTOP` 为 `true` 会保存到桌面而不是当前路径。

使用 `@clip` 文件名以写到宿主的剪贴板。

> [!NOTE]
>
> 使用 `stat(4)` 读取剪贴板，但是剪贴板的内容只会在运行时按下 CTRL-V 后才提供（出于安全考虑）。

### TIME()  
### T()

返回从卡带运行开始流逝的秒数。

这不是真实世界的时间，而是通过计数 `_UPDATE` 或 `_UPDATE60` 调用的次数来计算的。同一帧下，多次调用 `TIME()` 返回的是相同的结果。

### STAT(X)

获取系统状态，其中 `X` 是：

| X      | 含义                                             |
| ------ | ------------------------------------------------ |
| 0      | 内存用量（0..2048）                              |
| 1      | 从上一次翻转开始，CPU的占用率（1.0 == 100% CPU） |
| 4      | 剪贴板内容（用户按下 CTRL-V 后）                 |
| 6      | 参数字符串                                       |
| 7      | 当前帧率                                         |
| 46..49 | 当前在通道 0..3 上播放的 SFX 索引                |
| 50..53 | 在通道 0..3 上的音符号（0..31）                  |
| 54     | 当前播放的样式索引                               |
| 55     | 总共播放的样式数                                 |
| 56     | 当前样式播放了几个时间刻                         |
| 57     | （布尔值）如果音乐正在播放则为 `TRUE`            |
| 80..85 | UTC 时间：年，月，日，时，分，秒                 |
| 90..95 | 本地时间                                         |
| 100    | 当前的面包屑标签，或是 `nil`                     |
| 110    | 如果在逐帧模式，返回 `TRUE`                      |

> [!NOTE]
>
> 音频部分，数值 16..26 是音频状态查询相关数值 46..56 的旧版本。它们只报告音频混音器的当前状态，该状态一秒只改变大约 20 次（取决于宿主声卡驱动以及其它因素）。数值 46..56 则是存储每个时间刻上混音器状态的历史，这样能对当前声音状态有更高精度的评估。

### EXTCMD(CMD_STR, [P1, P2])

特殊系统命令，其中 `CMD_STR` 是一个字符串：

| CMD_STR        | 含义                                  |
| -------------- | ------------------------------------- |
| "pause"        | 请求打开暂停菜单                      |
| "reset"        | 请求重置卡带                          |
| "go_back"      | 如果存在，回到先前的卡带              |
| "label"        | 设置卡带标签                          |
| "screen"       | 保存屏幕截图                          |
| "rec"          | 设置视频起始点                        |
| "rec_frames"   | 在帧模式下设置视频起始点              |
| "video"        | 保存一个 `.gif` 到桌面                |
| "audio_rec"    | 开始录制音频                          |
| "audio_end"    | 保存录制的音频到桌面（Web 不支持）    |
| "shutdown"     | 退出卡带（从导出的二进制文件）        |
| "folder"       | 在宿主操作系统上打开当前工作目录      |
| "set_filename" | 设置屏幕截图 / gif / 录制音频的文件名 |
| "set_title"    | 设置宿主窗口标题                      |

有些命令有可选的数字参数：

"video"：覆盖系统设置的整数缩放因子  
"screen"：大于 0 时，保存到当前文件夹而不是桌面  
"audio_end"：大于 0 时，保存到当前文件夹而不是桌面

### 录制 GIF

`EXTCMD("REC")` ，`EXTCMD("VIDEO")` 和使用 CTRL-8，CTRL-9 是一样的，这会使用当前的 `GIF_SCALE` 设置（用 `CONFIG GIF_SCALE` 修改）保存一个 gif 到桌面。

两个额外参数可以用来覆盖默认值：

``````lua
EXTCMD("VIDEO", 4)    -- 缩放 *4 (512 X 512)
EXTCMD("VIDEO", 0, 1) -- 默认缩放，保存到用户数据文件夹
``````

用户数据文件夹可以用 `EXTCMD("FOLDER")` 打开，默认是和卡带的路径一样，对于导出的二进制文件则是 `{pico-8 appdata}/appdata/appname` 。

由于 gif 格式的本质，所有录制的 gif 是以 33.3fps 录制的，PICO-8 产生的帧在 gif 里会跳过或重复，从而大致对应上用户所看见的内容。若要在每次调用 `FLIP()` 的时候录制恰好一帧，不管运行时的帧率或者生成帧所用的时间，使用：

``````lua
EXTCMD("REC_FRAMES")
``````

gif（以及屏幕截图，音频）的默认文件名是 `foo_%d` ，其中 `foo` 是卡带的名称，而 `%d` 是一个从 0 开始的数字，其会自动增长，直到不存在拥有该名字的文件。使用 `EXTCMD("SET_FILENAME", "FOO")` 可以覆盖这个默认值。如果自定义文件名包含 `%d` ，那么也会使用这种数字自动增长的行为，否则，即使存在相同名字的文件也会写入文件。

## 6.2 图形

PICO-8 有一个固定的存放 128 个 8x8 精灵的空间，再加上 128 个与地图数据的下半部分（“共享数据”）重叠的空间。这 256 个精灵统一起来叫做精灵表（Sprite sheet），可以看作是一幅 128x128 的像素图像。

所有 PICO-8 的绘图操作遵循当前的绘制状态。绘制状态包括相机位置（用来给所有的坐标加上一个偏移值），调色板映射（用来给精灵重新着色），裁剪矩形，绘制颜色和填充图案。

每次运行一个程序，或者调用 `RESET()` 时，绘制状态都会重置。

颜色索引：

| 索引值 | 颜色 | 索引值 | 颜色   | 索引值 | 颜色   | 索引值 | 颜色   |
| ------ | ---- | ------ | ------ | ------ | ------ | ------ | ------ |
| 0      | 黑色 | 1      | 深蓝色 | 2      | 深紫色 | 3      | 深绿色 |
| 4      | 棕色 | 5      | 深灰色 | 6      | 淡灰色 | 7      | 白色   |
| 8      | 红色 | 9      | 橙色   | 10     | 黄色   | 11     | 绿色   |
| 12     | 蓝色 | 13     | 靛蓝色 | 14     | 粉色   | 15     | 桃红色 |

### CLIP(X, Y, W, H, [CLIP_PREVIOUS])

以像素为单位，设置裁剪矩形。所有绘图操作会被裁剪到一个矩形内，矩形位于 `X` ，`Y` ，宽度为 `W` ，高度为 `H` 。

调用 `CLIP()` 重置。

`CLIP_PREVIOUS` 为 `true` 的时候，用旧的裁剪区域裁剪新区域。

### PSET(X, Y, [COL])

设置位于 `X` ，`Y` 的像素的颜色索引值为 `COL`（0..15）。

未指定 `COL` 时，使用当前的绘制颜色。

``````lua
FOR Y=0,127 DO
  FOR X=0,127 DO
    PSET(X, Y, X*Y/8)
  END
END
``````

### PGET(X, Y)

返回屏幕上坐标为（`X`，`Y`）的像素的颜色。

``````lua
WHILE (TRUE) DO
  X, Y = RND(128), RND(128)
  DX, DY = RND(4)-2, RND(4)-2
  PSET(X, Y, PGET(DX+X, DY+Y))
END
``````

`X` 和 `Y` 越界的时候，`PGET` 返回 0。可以用下面的代码指定自定义返回值：

``````lua
POKE(0x5f36, 0x10) POKE(0x5f5B, NEWVAL)
``````

### SGET(X, Y)

### SSET(X, Y, [COL])

获取或设置一个精灵表像素的颜色（`COL`）。

`X` 和 `Y` 越界的时候，`SGET` 返回 0。可以用下面的代码指定自定义返回值：

``````lua
POKE(0x5f36, 0x10) POKE(0x5f59, NEWVAL)
``````

### FGET(N, [F])

### FSET(N, [F], VAL)

获取或设置精灵 `N` 的标志 `F` 的值（`VAL`）

`F` 是标志索引 0..7。

`VAL` 是 `TRUE` 或 `FLASE` 。

标志 0..7 的初始状态可以在精灵编辑器内设置，所以标志可以用来建立自定义精灵属性，还能通过给 `MAP()` 提供掩码来只绘制地图瓦片的一部分。

如果省略了 `F` ，所有的标志就会被当作单一的位域进行获取 / 置位。

``````lua
FSET(2, 1 | 2 | 8)   -- 置位 0，1 和 3
FSET(2, 4, TRUE)     -- 置位 4
PRINT(FGET(2))       -- 27 (1 | 2 | 8 | 16)
``````

### PRINT(STR, X, Y, [COL])

### PRINT(STR, [COL])

打印字符串 `STR` 。可选的，设置绘制颜色为 `COL` 。

简写：写在一行上，`?` 可以用于不带括号地调用 `print` ：

``````lua
?" HI"
``````

没有指定 `X` ，`Y` 的时候，后面会自动追加上一个换行符。用一个显式的终止控制字符结束字符串可以忽略掉这个字符：

``````lua
?" THE QUICK BROWN FOX\0"
``````

另外，没有指定 `X` ，`Y` 的时候，在低于 122 的地方打印文本会导致控制台滚动。这可以在运行时用 `POKE(0x5f36,0x40)` 禁用。

`PRINT` 返回打印时最右边的 x 坐标。利用这一点，我们可以通过在屏幕以外打印文本来得知文本的宽度：

``````lua
W = PRINT("HOGE", 0, -20) -- 返回 16
``````

关于控制代码和自定义字体的信息，参阅“附录 A（P8SCII）”。

### CURSOR(X, Y, [COL])

设置光标位置。

如果指定了 `COL` ，还会设置当前颜色。

### COLOR([COL])

设置绘图函数用到的当前颜色。

如果没有指定 `COL` ，当前颜色设置为 6。

### CLS([COL])

清除屏幕并重置裁剪矩形。

`COL` 默认是 0（黑色）。

### CAMERA([X, Y])

对于所有的绘图操作，设置屏幕偏移值为 `-X` ，`-Y` 。

调用 `CAMERA()` 重置。

### CIRC(X, Y, R, [COL])

### CIRCFILL(X, Y, R, [COL])

在坐标 `X` ，`Y` 绘制圆形或实心圆形，半径为 `R` 。

如果 `R` 是负数，圆形将不会绘制。

当 `COL` 置位了 `0x1800.0000` ，并且 `PEEK(0x5F34) & 2 == 2` 时，圆形会反转颜色绘制。

### OVAL(X0, Y0, X1, Y1, [COL])

### OVALFILL(X0, Y0, X1, Y1, [COL])

按照给定的边界矩形，绘制一个在 `X` 和 `Y` 上均对称的椭圆形。

### LINE(X0, Y0, [X1, Y1, [COL]])

绘制从（`X0`，`Y0`）到（`X1`，`Y1`）的直线。

如果没有提供（`X1`，`Y1`），则使用最后一次绘制的直线的终点。

没有参数的 `LINE()` 意思是下一次调用 `LINE(X1, Y1)` 只会设置终点而不会绘制。

``````lua
CLS()
LINE()
FOR I=0,6 DO
  LINE(64+COS(I/6)*20, 64+SIN(I/6)*20, 8+I)
END
``````

### RECT(X0, Y0, X1, Y1, [COL])

### RECTFILL(X0, Y0, X1, Y1, [COL])

绘制一个矩形或者实心矩形，对角的位置分别在（`X0`，`Y0`）和（`X1`，`Y1`）。

### RRECT(X, Y, W, H, R, [COL])

### RRECTFILL(X, Y, W, H, R, [COL])

绘制一个圆角矩形或者实心圆角矩形。

宽度（`W`）和高度（`H`）均以像素为单位，若要绘制该形状，两者就必须大于 0。

半径（`R`）默认值为 0，其为在每个角上绘制的四分之一圆的大小。传入的半径会被限制在 `0 .. min(width,height)/2` 的范围。

绘制一个红色（8 号颜色）圆角矩形，其宽达 40 像素，高达 30 像素，每个角上缺失 3 个像素（半径为 2）：

```lua
RRECTFILL(50,80,40,30,2,8)
```

当 `COL` 置位了 `0x1800.0000` ，并且 `PEEK(0x5F34) & 2 == 2` 时，`RRECTFILL` 会反转颜色进行绘制。

### PAL(C0, C1, [P])

`PAL()` 在三个调色板重映射中的一个映射中替换颜色 `C0` 为 `C1`（`P` 默认是 0）：

0：绘制调色板

绘制调色板重映射绘制时的颜色。例如，通过设置第 9 个调色板值为 8，一个橙色花的精灵可以绘制成红色花：

``````lua
PAL(9,8)     -- 之后，绘制橙色（颜色 9）像素为红色（颜色 8）
SPR(1,70,60) -- 精灵中的任何橙色像素转而会被绘制成红色
``````

改变绘制调色板并不会影响已经绘制到屏幕上的内容。

1：显示调色板

当屏幕在帧尾显示的时候，显示调色板会重映射整个屏幕。例如，如果你启动 PICO-8 然后输入 `PAL(6, 14, 1)` ，你可以看到即使文本已经绘制到了屏幕上，灰色（颜色 6）的文本会立即变成粉色（颜色14）。这在制作像是淡入淡出的全屏效果时比较有用。

2：辅助调色板

由 `FILLP()` 使用，用来绘制精灵。它提供了把单个 4 位颜色索引映射到两个 4 位颜色索引的功能。

`PAL()` 重置所有的调色板到系统默认值（包括透明值）  
`PAL(P)` 重置特定的调色板（0..2）到系统默认值

### PAL(TBL, [P])

`PAL` 的第一个参数是一个表的时候，对于每一个条目，颜色分别进行赋值。例如，把颜色 12 和 14 重映射到红色：

``````lua
PAL({[12]=9,[14]=8})
``````

或者把整个屏幕重新着色为灰色调（包括已经绘制的一切）：

``````lua
PAL({1,1,5,5,5,6,7,13,6,7,7,6,13,6,7,1}, 1)
``````

因为表的索引以 1 开始，在这种情况下，颜色 0 在末尾给出。

### PALT(C, [T])

设置颜色索引的透明度为 `T`（布尔值）。透明度由 `SPR()`，`SSPR()`，`MAP()` 和 `TLINE()` 使用。

``````lua
PALT(8, TRUE) -- 在接下来的 SPRITE/TLINE 绘制调用中，红色像素将不会绘制
``````

`PALT()` 重置透明度为默认值：除了颜色 0 ，所有的颜色都是不透明的。

当 `C` 是唯一的参数时，它会被当作设置所有 16 个值的位域。例如：设置颜色 0 和 1 是透明色：

``````lua
PALT(0B1100000000000000)
``````

### SPR(N, X, Y, [W, H], [FLIP_X], [FLIP_Y])

在坐标 `X`，`Y` 绘制精灵 `N`（0..255）。

`W`（宽度）和 `H`（高度）默认是 1，1，其指定了绘制在屏幕上时，有几个精灵之宽。

默认是颜色 0 作为透明色绘制（参阅 `PALT()`）

当 `FLIP_X` 是 `TRUE`，水平翻转。

当 `FLIP_Y` 是 `TRUE`，垂直翻转。

### SSPR(SX, SY, SW, SH, DX, DY, [DW, DH], [FLIP_X], [FLIP_Y]]

把精灵表上的一个矩形区域（`SX`，`SY`，`SW`，`SH`）拉伸绘制到屏幕上的目标矩形区域（`DX`，`DY`，`DW`，`DH`）。在两种情况下，`X` 值和 `Y` 值是矩形左上角的坐标（以像素为单位），宽度为 `W`，`H` 。

默认是颜色 0 作为透明色绘制（参阅 `PALT()`）

`DW`，`DH` 默认是 `SW`，`SH` 。

当 `FLIP_X` 是 `TRUE`，水平翻转。

当 `FLIP_Y` 是 `TRUE`，垂直翻转。

### FILLP(P)

PICO-8 填充图案是一个 4x4 的双色平铺图案，由 `CIRC()`，`CIRCFILL()`，`RECT()`，`RECTFILL()`，`OVAL()`，`OVALFILL()`，`PSET()`，`LINE()` 使用。

`P` 是一个位域，按照阅读顺序，从最高位开始。要计算 `P` 值以得到想要的图案，把下面对应位的值加起来：

| 32768 | 16384 | 8192 | 4096 |
| ----- | ----- | ---- | ---- |
| 2048  | 1024  | 512  | 256  |
| 128   | 64    | 32   | 16   |
| 8     | 4     | 2    | 1    |

例如，`FILLP(4+8+64+128+256+512+4096+8192)` 会产生棋盘图案。

这可以用二进制更优雅地表示：`FILLP(0b0011001111001100)`。

默认的填充图案是 0，这意味着绘制的是单个纯色。

要指定图案的第二种颜色，使用任何颜色参数的高位：

``````lua
FILLP(0b0011010101101000)
CIRCFILL(64,64,20, 0x4E) -- 棕色和粉色
``````

位 `0b0.111` 提供了额外的设置：

`0b0.100` 透明度

置这一位的时候，第二种颜色就不会绘制。

``````lua
-- 带有透明正方形的棋盘
FILLP(0b0011001111001100.1)
``````

`0b0.010` 应用到精灵

置这一位的时候，填充图案会应用到精灵（`SPR`，`SSPR`，`MAP`，`TLINE`），使用到辅助调色板提供的颜色映射。

精灵里每个像素值（跟往常一样应用绘制调色板之后）会被作为辅助调色板的索引。辅助调色板里的每个条目包含用于渲染填充图案的两种颜色。例如，在精灵中，只对于蓝色（颜色 12）像素绘制白红（颜色 7 和 8）棋盘图案：

``````lua
FOR I=0,15 DO PAL(I, I+I*16, 2) END  --  其他颜色映射到自身
PAL(12, 0x87, 2)                     --  在辅助调色板中重映射颜色 12
 
FILLP(0b0011001111001100.01)         --  棋盘调色板，应用到精灵
SPR(1, 64,64)                        --  绘制精灵
``````

`0b0.001` 全局应用辅助调色板

置这一位的时候，辅助调色板也会应用到所有关注填充图案的绘图函数（`CIRCFILL`，`LINE` 等等）。与精灵绘图函数一同使用的时候比较有用，这样每个精灵像素的颜色索引和提供给绘图函数的颜色索引的含义是一样的。

``````lua
FILLP(0b0011001111001100.001)
PAL(12, 0x87, 2)
CIRCFILL(64,64,20,12)                -- 红白棋盘圆形
``````

辅助调色板映射在寻常的绘制调色板映射完成后应用。所以下面的代码也会绘制红白棋盘圆形：

``````lua
PAL(3,12)
CIRCFILL(64,64,20,3)
``````

填充图案也可以通过在任意的颜色参数中置位来进行设置（例如，`COLOR()` 的参数，或者 `LINE()`、`RECT()` 的最后一个参数等等）。

`POKE(0x5F34, 0x3)` -- `0x1` 启用高位的填充图案，`0x2` 启用反转颜色模式  
`CIRCFILL(64,64,20, 0x114E.ABCD)` -- 设置填充图案为 `ABCD`

使用颜色参数设置填充图案时，以下几位要用到：

位 `0x1000.0000` ：这需要置位，意思是“检测位 `0xf00.ffff`”  
位 `0x0100.0000` ：透明度  
位 `0x0200.0000` ：应用到精灵  
位 `0x0400.0000` ：全局应用辅助调色板  
位 `0x0800.0000` ：绘图操作反转颜色（`CIRCFILL` / `OVALFILL` / `RECTFILL` / `RRECTFILL`）  
位 `0x00FF.0000` 是正常用到的颜色位  
位 `0x0000.FFFF` 解析为填充图案

## 6.3 表函数

> [!WARNING]
>
> 除了`PAIRS()` ，下列的函数和 `#` 运算符只适用于索引从 1 开始并且没有 `NIL` 条目的表。其它形式的表可以看作是哈希表或者集合，而不是带有长度的数组。

### ADD(TBL, VAL, [INDEX])

将值 `VAL` 添加到表 `TBL` 的末尾。等价于：

``````lua
TBL[#TBL + 1] = VAL
``````

如果给定了 `INDEX` ，那么元素会插入到那个位置：

``````lua
FOO={}        -- 创建空表
ADD(FOO, 11)
ADD(FOO, 22)
PRINT(FOO[2]) -- 22
``````

### DEL(TBL, VAL)

从表 `TBL` 中删除值 `VAL` 的第一个实例。剩下的条目往左移动一个索引，避免空洞。

注意 `VAL` 是要删除的项目的值，而不是对表的索引。（要删除特定索引指向的项目，请改用 `DELI`）`DEL` 返回删除的项目，如果没有删除任何东西，就不返回值。

``````lua
A={1,10,2,11,3,12}
FOR ITEM IN ALL(A) DO
  IF (ITEM < 10) THEN DEL(A, ITEM) END
END
FOREACH(A, PRINT) -- 10,11,12
PRINT(A[3])       -- 12
``````

### DELI(TBL, [I])

类似 `DEL()` ，但是从表 `TBL` 中删除索引 `I` 指向的项目。如果没有给定 `I`，表的最后一个元素被删除并返回。 

### COUNT(TBL, [VAL])

返回表 `TBL` 的长度（和 `#TBL` 相同）。如果给定了 `VAL` ，返回这个表中 `VAL` 的实例数。

### ALL(TBL)

在 `FOR` 循环中使用，用来迭代表（有 1 开头的整数索引）中所有的项目，按照添加的顺序。

``````lua
T = {11,12,13}
ADD(T,14)
ADD(T,"HI")
FOR V IN ALL(T) DO PRINT(V) END -- 11 12 13 14 HI
PRINT(#T) -- 5
``````

### FOREACH(TBL, FUNC)

对于表 `TBL` 中的每个项目，调用函数 `FUNC` 并将项目作为单一参数。

``````lua
> FOREACH({1,2,3}, PRINT)
``````

### PAIRS(TBL)

在 `FOR` 循环中使用，用来迭代表 `TBL`，对于每个项目既提供键也提供值。不像 `ALL()` ，`PAIRS()` 迭代每个项目，不管索引方案如何。顺序不做保证。

``````lua
T = {["HELLO"]=3, [10]="BLAH"}
T.BLUE = 5;
FOR K,V IN PAIRS(T) DO
PRINT("K: ".. K.." V:".. V)
END
``````

输出：

``````
K: 10 v:BLAH
K: HELLO v:3
K: BLUE V:5
``````

## 6.4 输入

### BTN([B], [PL])

获取玩家 `PL`（默认是 0）的按钮 `B` 状态。

`B`：`0..5`：左 右 上 下 按钮O 按钮X  
`PL`：玩家索引 `0..7`

除了传给 `B` 数字，也可以使用按钮字形。（在代码编辑器，使用 Shift-L R U D O X）

如果不提供参数，返回玩家 0 & 1 的所有 12 个按钮状态组成的位域 // P0：位 `0..5` P1：位 `8..13`

玩家按钮的默认键盘映射：

玩家 0：[DPAD]：方向键，[O]：Z C N，[X]：X V M  
玩家 1：[DPAD]：SFED，[O]：左 SHIFT，[X]：TAB W Q A

> [!WARNING]
>
> 虽然 PICO-8 能接受所有的按键组合，但要注意在一个实体游戏控制器上，同时按下左和右一般是不可能的。在一些控制器上，如果能够使用 [X] 或 [O] 而不是上，上 + 左 / 右 的键位也会很尴尬（例如跳跃 / 加速）。

### BTNP(B, [PL])

`BTNP` 是“按钮按下（Button Pressed）”的简写；并非是按钮按住的时候返回 `true`，`BTNP` 只当按钮按下**并且**上一帧没有按下的时候返回 `true`。它还会在 15 帧后重复，在那之后每 4 帧返回 `true`（以 30fps 的帧率 -- 翻倍后就是 60fps）。这可以用于菜单导航或者基于网格的玩家移动。

`BTNP` 读取的状态会在每次 `_UPDATE` 或 `_UPDATE60` 调用的开始时重置，所以最好在这些函数的其中之一里使用 `BTNP`。

可以通过写入下列内存地址来设置自定义延迟（在 30fps 帧率下）：

``````lua
POKE(0X5F5C, DELAY) -- 设置重复前的初始延迟。255 表示永不重复。
POKE(0X5F5D, DELAY) -- 设置重复延迟。
``````

在两种情形下，可以用 0 表示默认行为（延迟为 15 和 4）

## 6.5 音频

### SFX(N, [CHANNEL], [OFFSET], [LENGTH])

在通道 `CHANNEL`（`0..3`）上播放 SFX `N`（`0..63`），从音符 `OFFSET` 开始演奏（音符中的 `0..31`），音符数量为 `LENGTH` 。

负数的 `CHANNEL` 有特殊含义：

`CHANNEL -1`：（默认）自动选择未使用的通道  
`CHANNEL -2`：停止给定的声音在任何通道上播放

`N` 可以是给通道 `CHANNEL` 的命令（`CHANNEL` 小于 0 时则是所有通道）：

`N -1`：停止那个通道的声音  
`N -2`：释放那个通道上的声音，不再循环

``````lua
SFX(3)    --  播放 SFX 3
SFX(3,2)  --  在通道 2 上播放 SFX 3
SFX(3,-2) --  停止 SFX 3 在任何通道上播放
SFX(-1,2) --  停止在通道 2 上播放的声音
SFX(-2,2) --  释放通道 2 上的循环
SFX(-1)   --  停止所有通道上的所有声音
SFX(-2)   --  释放所有通道上的循环
``````

### MUSIC(N, [FADE_LEN], [CHANNEL_MASK])

播放从样式 `N`（`0.63`）开始的音乐。  
`M` 为 -1 时停止音乐。

`FADE_LEN` 的单位是毫秒（默认值：0）。所以要以淡入方式播放样式 0，且淡入时间为 1 秒，用：

``````lua
MUSIC(0, 1000)
``````

`CHANNEL_MASK` 指定要保留哪些通道只给音乐使用。例如，只在通道 `0..2` 上播放：

``````lua
MUSIC(0, NIL, 7) -- 1 | 2 | 4
``````

被保留的通道仍然可以用来播放音效，但是仅当该通道的索引由 `SFX()` 显式指定的时候可行。

## 6.6 地图

PICO-8 地图是由 8 位值组成的 128x32 的网格，用到共享内存后则是 128x64。使用地图编辑器的时候，每个数值的含义就是指向精灵表（`0..255`）的索引。然而，它也可以被当作一个通用数据块。

### MGET(X, Y)

### MSET(X, Y, VAL)

获取或设置坐标为 `X`，`Y` 的地图数值（`VAL`）。

`X` 和 `Y` 越界的时候，`MGET` 返回 0。可以用下面的代码指定自定义返回值：

``````lua
POKE(0x5f36, 0x10) POKE(0x5f5a, NEWVAL)
``````

### MAP(TILE_X, TILE_Y, [SX, SY], [TILE_W, TILE_H], [LAYERS])

在屏幕坐标 `SX`，`SY`（像素单位）绘制地图区域（从 `TILE_X`，`TILE_Y` 开始）。

在屏幕坐标 20，20 绘制 4x2 的瓦片块，其从地图坐标 0，0 开始：

``````lua
MAP(0, 0, 20, 20, 4, 2)
``````

`TILE_W` 和 `TILE_H` 默认是整个地图（如果合适的话还会包括共享空间）。

`MAP()` 经常和 `CAMERA()` 一同使用。绘制地图，使得玩家对象（坐标在 `PL.X`，`PL.Y`，像素单位）居中：

``````lua
CAMERA(PL. X - 64, PL. Y - 64)
MAP()
``````

`LAYERS` 是位域。给定后，只有带有对应精灵标志的精灵才能被绘制。例如，`LAYERS` 是 `0x5` 的时候，只有带有标志 1 和 2 的精灵能被绘制。

0 号精灵会被认为是“空白”，从而不会被绘制。要禁用这个行为，使用：`POKE(0x5F36, 0x8)`。

### TLINE(X0, Y0, X1, Y1, MX, MY, [MDX, MDY], [LAYERS])

绘制从（`X0`，`Y0`）到（`X1`，`Y1`）的带纹理的直线，颜色值从地图采样。指定了 `LAYERS` 的时候，只有带有对应标志的精灵才能被绘制（和 `MAP()` 相似）

`MX`，`MY` 是采样的地图坐标，以瓦片为单位。颜色值从每个地图瓦片上存在的 8x8 精灵里采样得到。例如：

`2.0`，`1.0` 的意思是地图坐标 2，1 上的精灵的左上角  
`2.5`，`1.5` 的意思是同一个精灵上坐标为（4，4）的像素

`MDX`，`MDY` 是每个像素绘制完后加到 `MX`，`MY` 上的增量。（默认是 `0.125`，`0`）

地图坐标（`MX`，`MY`）会被掩码掩盖，掩码的计算方法是分别把内存地址 `0x5F38` 和 `0x5F39` 上的数值减去 `0x0.0001`。简单来说，这意味着往内存中写入你想要循环的区域的宽度和高度，你就可以对地图的一个区域进行循环采样，只要宽度和高度是 2 的幂（2，4，8，16..）

例如，水平方向每 8 个瓦片循环一次，垂直方向每 4 个瓦片循环一次：

``````lua
POKE(0x5F38, 8) POKE(0x5F39, 4) SLOPES (...)
``````

默认值（0，0）给定的掩码是 `0xff.ffff`，意思是每 256 个瓦片循环采样一次。

还可以在内存地址 `0x5F3A`，`0x5F3B` 上指定采样的偏移值（也是以瓦片为单位）：

``````lua
POKE(0x5F3A, OFFSET_X) POKE(0x5F3B, OFFSET_Y)
``````

0 号精灵会被认为是“空白”，从而不会被绘制。要禁用这个行为，使用：`POKE(0x5F36, 0x8)`。

#### 设置 TLINE 精度

默认情况下，`TLINE` 坐标（`MX`，`MY`，`MDX`，`MDY`）是以瓦片为单位表示的，也就意味着 1 个像素是 `0.125`，只有 13 个位用于分数部分。如果需要更多精度，坐标空间可以调整，分数部分就可以有更多位数。对于像是带纹理的墙面这样的事物而言比较有用，因为靠近观察的时候可能会展现出 `MDX`，`MDY` 舍入带来的累积性错误。

每个像素的分数部分所用到的位数存储在一个特殊的寄存器里，可以通过用单个参数调用 `TLINE` 一次来调整：

``````lua
TLINE(16) -- MX，MY，MDX，MDY 将以像素为单位表示
``````

## 6.7 内存

PICO-8 有 3 种内存：

1. 基础 RAM（64k）：参见下文的布局。用 `PEEK()`，`POKE()`，`MEMCPY()`，`MEMSET()` 访问
2. 卡带 ROM（32k）：和基础 RAM 内存地址 `0x4300` 之前的布局相同
3. Lua RAM（2MB）：编译后的程序 + 变量

> [!NOTE]
>
> 技术性信息：使用编辑器的时候，修改的数据是在卡带 ROM 中，但是像是 `SPR()` 和 `SFX()` 这样的 API 函数只在基础 RAM 上进行操作。在以下 3 种情况下，PICO-8 会自动把卡带 ROM 复制到基础 RAM（也就是调用 `RELOAD()`）：
>
> 1. 卡带加载后
> 2. 卡带运行后
> 3. 退出任意一个编辑器模式的时候 // 这可以用 `POKE(0x5F37,1)` 关闭

### 基础 RAM 内存布局

| 内存地址 | 内容描述                   |
| -------- | -------------------------- |
| 0x0      | GFX                        |
| 0x1000   | GFX2 / 地图 2（共享）      |
| 0x2000   | 地图                       |
| 0x3000   | GFX 标志                   |
| 0x3100   | 乐曲                       |
| 0x3200   | SFX                        |
| 0x4300   | 用户数据                   |
| 0x5600   | 自定义字体（如果有定义）   |
| 0x5E00   | 持久性卡带数据（256 字节） |
| 0x5F00   | 绘制状态                   |
| 0x5F40   | 硬件状态                   |
| 0x5F80   | GPIO 引脚（128 字节）      |
| 0x6000   | 屏幕（8K）                 |
| 0x8000   | 用户数据                   |

用户数据没有特别的含义，可以通过`MEMCPY()`，`PEEK()` & `POKE()` 将其用作任意用途。持久性卡带数据被映射到了 `0x5E00..0x5EFF`，只有调用 `CARTDATA()` 才能存储。颜色格式（GFX / 屏幕）是每字节 2 像素：低位编码的是每对像素的左侧像素。地图格式是每个瓦片一个字节，其中每个字节正常情况下编码的是一个精灵索引。

### 重映射图形和地图数据

设置下列内存地址上的数值，GFX，地图和屏幕内存区域就能重新分配：

> `0x5F54` GFX：可以是 `0x00` (默认）或 `0x60`（使用屏幕内存作为精灵表）  
> `0x5F55` 屏幕：可以是 `0x60`（默认）或 `0x00`（使用精灵表作为屏幕内存）  
> `0x5F56` 地图：可以是 `0x20`（默认）或 `0x10..0x2F`，或 `0x80` 以及更高  
> `0x5F57` 地图大小：地图宽度。0 的意思是 256。默认是 128

地址可以以 256 字节的增量表示。所以 `0x20` 的意思是 `0x2000`，`0x21` 的意思是 `0x2100`，以此类推。地图地址 `0x30..0x3F` 会被认为是内存地址 `0x10..0x1F`（共享内存区域）。地图数据只能存放在内存区域 `0x1000..0x2FFF`，`0x8000..0xFFFF`，地图高度确定为适合给定内存区域的最大可能大小。

此外，GFX 和屏幕地址可以映射到高位内存位置 `0x80`，`0xA0`，`0xC0`，`0xE0`，有个约束条件是地图不能与该地址有重叠（若出现这种情况，冲突的 GFX 和 / 或屏幕映射会回到各自的默认映射）。

> [!NOTE]
>
> GFX 和屏幕内存映射在底层发生，这也会影响内存访问函数（`PEEK`，`POKE`，`MEMCPY`）。`0x0` 和 `0x6000` 开始的 8k 内存块可以看作是指向一块单独的视频 RAM 的指针，设置内存地址 `0x5F54` 和 `0x5F56` 上的数值会影响这些指针。

### PEEK(ADDR, [N])

在基础 RAM 中，从一个内存地址中读取一个字节。如果指定了 `N`，`PEEK()` 读取 `N` 个字节并返回（最大值：8192）。例如，读取视频内存开头的 2 个字节：

``````lua
A, B = PEEK(0x6000, 2)
``````

### POKE(ADDR, VAL1, VAL2, ...)

在基础 RAM 中，写入一个或多个字节到一个内存地址。如果提供了多于一个的参数，字节会按顺序写入（最大值：8192）。

### PEEK2(ADDR)

### POKE2(ADDR, VAL)

### PEEK4(ADDR)

### POKE4(ADDR, VAL)

16 位和 32 位版本的 `PEEK` 和 `POKE`。以小端字节序格式读写一个数字（`VAL`）：

16 位：`0xFFFF.0000`  
32 位：`0xFFFF.FFFF`

`ADDR` 不需要与 2 或 4 字节边界对齐。

还有另一种方法，下列的运算符可以用来 `PEEK`（但不是 `POKE`），并且稍微快一点：

``````lua
@ADDR  -- PEEK(ADDR)
%ADDR  -- PEEK2(ADDR)
$ADDR  -- PEEK4(ADDR)
``````

### MEMCPY(DEST_ADDR, SOURCE_ADDR, LEN)

从源地址复制 `LEN` 字节的基础 RAM 到目的地址。内存段可以重叠。

### RELOAD(DEST_ADDR, SOURCE_ADDR, LEN, [FILENAME])

和 `MEMCPY` 相同，但是是从卡带 ROM 复制。

代码段（ >= `0x4300`）受到保护，无法读取。

如果指定了 `FILENAME`，就会从单独的卡带读取数据。在这种情况下，卡带必须位于本地（BBS 卡带不能用这种方式读取）。

### CSTORE(DEST_ADDR, SOURCE_ADDR, LEN, [FILENAME])

和 `MEMCPY` 相同，但是是从基础 RAM 复制到卡带 ROM。

`CSTORE()` 等价于 `CSTORE(0, 0, 0x4300)`。

代码段（ >= `0x4300`）受到保护，无法写入。

如果指定了 `FILENAME`，数据就会直接写到磁盘上的那个卡带。一次会话内可以写入多达 64 个卡带。若要获取更多信息，参阅“卡带数据”。

### MEMSET(DEST_ADDR, VAL, LEN)

把 8 位值 `VAL` 写入 `DEST_ADDR` 起始的内存区域，长度为 `LEN` 字节。

例如，用 `0xC8` 填充一半的视频内存：

``````lua
> MEMSET(0x6000, 0xC8, 0x1000)
``````

## 6.8 数学

### MAX(X, Y)

### MIN(X, Y)

### MID(X, Y, Z)

返回参数的最大值，最小值或中位数。

``````lua
> ?MID(7,5,10) -- 7
``````

### FLR(X)

``````lua
> ?FLR ( 4.1) -->  4
> ?FLR (-2.3) --> -3
``````

### CEIL(X)

返回等于 `X` 或小于 `X` 的最接近 `X` 的整数。

``````lua
> ?CEIL( 4.1) -->  5
> ?CEIL(-2.3) --> -2
``````

### COS(X)

### SIN(X)

返回 `X` 的余弦值或正弦值，其中 `1.0` 表示一个完整的周期。例如，要制作一个每秒钟旋转一圈的表盘动画：

``````lua
FUNCTION _DRAW()
  CLS()
  CIRC(64, 64, 20, 7)
  X = 64 + COS(T()) * 20
  Y = 64 + SIN(T()) * 20
  LINE(64, 64, X, Y)
END
``````

PICO-8 的 `SIN()` 返回符号相反的结果以符合屏幕空间（其中 Y 轴的正方向是向下，这与数学图表相反，那里 Y 轴的正方向一般都是向上）。

``````lua
> SIN(0.25) -- 返回 -1
``````

要获得传统的基于弧度的三角函数，并且 Y 轴不是反向的，请把下列的代码片段粘贴到靠近你的程序开头的位置：

``````lua
P8COS = COS FUNCTION COS(ANGLE) RETURN P8COS(ANGLE/(3.1415*2)) END
P8SIN = SIN FUNCTION SIN(ANGLE) RETURN -P8SIN(ANGLE/(3.1415*2)) END
``````

### ATAN2(DX, DY)

把 `DX`，`DY` 转换到 `0..1` 范围的角度。

和 `COS` / `SIN` 一样，角度在屏幕空间中是逆时针方向进行的。例如：

``````lua
> ?ATAN(0, -1) -- 返回 0.25
``````

`ATAN2` 还能用于寻找两点之间的方向：

``````lua
X=20 Y=30
FUNCTION _UPDATE()
  IF (BTN(0)) X-=2
  IF (BTN(1)) X+=2
  IF (BTN(2)) Y-=2
  IF (BTN(3)) Y+=2
END
 
FUNCTION _DRAW()
  CLS()
  CIRCFILL(X,Y,2,14)
  CIRCFILL(64,64,2,7)
   
  A=ATAN2(X-64, Y-64)
  PRINT("ANGLE: "..A)
  LINE(64,64,
    64+COS(A)*10,
    64+SIN(A)*10,7)
END
``````

### SQRT(X)

返回 `X` 的平方根。

### ABS(X)

返回 `X` 的绝对（正）值。

### RND(X)

返回一个随机数 n，其中 0 <= n < `X`。

如果你需要一个整数，使用 `FLR(RND(X))`。如果 `X` 是一个数组风格的表，就会在 `TABLE[1]` 和 `TABLE[#TABLE]` 之间返回一个随机元素。

### SRAND(X)

设置随机数种子。卡带启动时，种子会自动随机生成。

``````lua
FUNCTION _DRAW()
  CLS()
  SRAND(33)
  FOR I=1,100 DO
    PSET(RND(128),RND(128),7)
  END
END
``````

### 按位操作

按位操作和逻辑表达式比较相似，除了按位操作是与位打交道。

比方说你有两个数字（这里使用 `0b` 前缀，用二进制书写）：

``````lua
X = 0b1010
Y = 0b0110
``````

按位与操作会返回一个数字，里面的位仅当 `X` 和 `Y` 中的对应位都置位的情况下才置位。

``````lua
> PRINT(BAND(X,Y)) -- 结果：0B0010 (写成十进制就是2)
``````

PICO-8 中有 9 个按位函数：

``````lua
BAND(X, Y) -- 两个位都置位了
BOR(X, Y)  -- 只要有一个置位
BXOR(X, Y) -- 有一个置位，但不要两个都置位
BNOT(X)    -- 每一位都反向设置
SHL(X, N)  -- 左移 N 位（右侧补0）
SHR(X, N)  -- 算术右移（最左边一位的状态会重复补偿）
LSHR(X, N) -- 逻辑右移（左侧补0）
ROTL(X, N) -- X 中的所有位向左旋转 N 位
ROTR(X, N) -- X 中的所有位向右旋转 N 位
``````

也存在运算符版本：`&`，`|`，`^^`，`~`，`<<`，`>>`，`>>>`，`<<>`，`>><`

例如：`PRINT(67 & 63) -- 结果：3 等价于 BAND(67,63)`

运算符比它们对应的函数要稍微快一点。行为基本上一样，除了如果任何一个操作数不是数字，结果就是运行时错误（函数版本则返回默认值 0）。

### 整除

可以用 `\` 进行整除。

``````lua
> PRINT(9\2) -- 结果：4  等价于 FLR(9/2)
``````

## 6.9 自定义菜单项

### MENUITEM(INDEX, [LABEL], [CALLBACK])

往暂停菜单中添加或更新一个菜单项。

`INDEX` 应该介于 `1..5`，决定了每个菜单项的显示顺序。

`LABEL` 应该是一个最长 16 个字符的字符串。

`CALLBACK` 是用户选择该菜单项时调用的函数，如果回调返回了 `true`，暂停菜单保持打开状态。

如果没有提供标签或函数，菜单项就会被移除。

``````lua
MENUITEM(1, "RESTART PUZZLE",
  FUNCTION() RESET_PUZZLE() SFX(10) END
)
``````

回调接受单一参数，那就是 L，R，X 按钮按下状态的位域。

``````lua
MENUITEM(1, "FOO",
  FUNCTION(B) IF (B&1 > 0) THEN PRINTH("LEFT WAS PRESSED") END END
)
``````

如果要过滤触发回调所用的按键，可以在 `INDEX` 的位 `0xFF00` 提供一个掩码。例如，要对一个特定的菜单项禁用 L，R，在 `INDEX` 中置位 `0x300`：

``````lua
MENUITEM(2 | 0x300, "RESET PROGRESS",
  FUNCTION() DSET(0,0) END
)
``````

可以在回调内更新，添加或移除菜单项：

``````lua
MENUITEM(3, "SCREENSHAKE: OFF",
  FUNCTION()
    SCREENSHAKE = NOT SCREENSHAKE
    MENUITEM(NIL, "SCREENSHAKE: "..(SCREENSHAKE AND "ON" OR "OFF"))
    RETURN TRUE -- 不关闭
  END
)
``````

## 6.10 字符串和数据类型转换

Lua 内的字符串要么在单双引号内书写，要么在配对的 `[[ ]]` 括号内书写：

``````lua
S = "THE QUICK"
S = 'BROWN FOX';
S = [[
  JUMPS OVER
  MULTIPLE LINES
]]
``````

字符串的长度（字符数量）可以用 `#` 运算符获取：

``````lua
>PRINT(#S)
``````

字符串可以用 `..` 运算符拼接。拼接数字会将它们转换为字符串。

``````lua
>PRINT("THREE "..4) --> "THREE 4"
``````

用作算术表达式的一部分时，字符串会被转换为数字：

``````lua
>PRINT(2+"3")   --> 5
``````

### TOSTR(VAL, [FORMAT_FLAGS])

把 `VAL` 转换成字符串。

`FORMAT_FLAGS` 是一个位域：

`0x1`：写入数字，函数或表的原始十六进制值  
`0x2`：通过把 `VAL` 左移 16 位，把 `VAL` 写作有符号 32 位整数

`TOSTR(NIL)` 返回 `"[nil]"`。

`TOSTR()` 返回 `""`。

``````lua
TOSTR(17)       -- "17"
TOSTR(17,0x1)   -- "0x0011.0000"
TOSTR(17,0x3)   -- "0x00110000"
TOSTR(17,0x2)   -- "1114112"
``````

### TONUM(VAL, [FORMAT_FLAGS])

把 `VAL` 转换成数字。

``````lua
TONUM("17.5")  -- 17.5
TONUM(17.5)    -- 17.5
TONUM("HOGE")  -- 无返回值
``````

`FORMAT_FLAGS` 是一个位域：

`0x1`：把字符串当作没有 `0x` 前缀的（无符号，整数）十六进制数进行读取。非十六进制数字符会被当作 0。  
`0x2`：把字符串当作有符号 32 位整数读取，随后右移 16 位。  
`0x4`：`VAL` 不能转换成数字的时候返回 0。

``````lua
TONUM("FF",       0x1)  -- 255
TONUM("1114112",  0x2)  -- 17
TONUM("1234abcd", 0x3)  -- 0x1234.abcd
``````

### CHR(VAL0, VAL1, ...)

把一个或多个序数字符代码转换成字符串。

``````lua
CHR(64)                    -- "@"
CHR(104,101,108,108,111)   -- "hello"
``````

### ORD(STR, [INDEX], [NUM_RESULTS])

把字符串 `STR` 中一个或多个字符转换成它们的序数（`0..255`）字符代码。

使用 `INDEX` 参数来指定字符串中要用到哪个字符。`INDEX` 越界或者 `STR` 不是字符串的时候，`ORD` 返回 `NIL`。

给定 `NUM_RESULTS` 的时候，`ORD` 返回从 `INDEX` 开始的多个数值。

``````lua
ORD("@")         -- 64
ORD("123",2)     -- 50 (第二个字符："2")
ORD("123",1,3)   -- 49,50,51
``````

### SUB(STR, POS0, [POS1])

从字符串 `STR` 中获取子字符串，从 `POS0` 开始到 `POS1`，包括 `POS1`，未指定 `POS1` 的时候，返回的是剩下的整个字符串。指定了不是数字的 `POS1` 的时候，返回 `POS0` 处的单个字符。

``````lua
S = "THE QUICK BROWN FOX"
PRINT(SUB(S,5,9))   --> "QUICK"
PRINT(SUB(S,5))     --> "QUICK BROWN FOX"
PRINT(SUB(S,5,_))   --> "Q"
``````

### SPLIT(STR, [SEPARATOR], [CONVERT_NUMBERS])

把一个字符串按照给定的分隔符（默认是 `,`）划分，形成由元素组成的表。分隔符是数字 N 的时候，字符串会被分割成 N 个字符长度的几组。`CONVERT_NUMBERS` 是 `true` 的时候，数值 Token 会作为数字进行存储（默认是 `true`）。空元素会作为空字符串进行存储。

``````lua
SPLIT("1,2,3")               -- {1,2,3}
SPLIT("ONE:TWO:3",":",FALSE) -- {"ONE","TWO","3"}
SPLIT("1,,2,")               -- {1,"",2,""}
``````

### TYPE(VAL)

以字符串的形式返回 `VAL` 的类型。

``````lua
> PRINT(TYPE(3))
NUMBER
> PRINT(TYPE("3"))
STRING
``````

## 6.11 卡带数据

使用 `CARTDATA()`，`DSET()` 和 `DGET()`，64 个数字长度（256 字节）的持久性数据可以存储在用户的 PICO-8 上，卡带卸载后或 PICO-8 关机后依然会持续存在。这可以用作一种保存像是高分，或玩家进度这样的东西的轻量级方法。这还可以用来跨卡带 / 跨卡带版本共享数据。

如果需要多于 256 字节的空间，也可以用 `CSTORE()` 直接写入卡带。缺点是数据就会与那个版本的卡带紧密绑定了。比方说，如果游戏更新了，玩家就会失去存档。并且，卡带数据段中的一些空间需要保持可用，以用作存储。

另一种方法是给 `CSTORE()` 指定第四个参数，直接写入第二张卡带。这需要做一次卡带交换（这在现实中只意味着用户需要看 1 秒钟的旋转卡带动画）。

``````lua
CSTORE(0,0,0X2000, "SPRITE SHEET.P8")
-- 之后，恢复保存的数据：
RELOAD(0,0,0X2000, "SPRITE SHEET.P8")
``````

### CARTDATA(ID)

由 `ID` 作索引，打开一个永久数据存储槽位。之后使用 `DSET()` 和 `DGET()`，它可用来存取多达 256 字节（64 个数字长度）的数据。

``````lua
CARTDATA("ZEP_DARK_FOREST")
DSET(0, SCORE)
``````

`ID` 是一个最长 64 个字符的字符串，并且应当足够独特，这样其它卡带不会意外地使用相同的 `ID`。合法字符是 `a..z`，`0..9` 和下划线（`_`）。

如果数据加载完成，返回 `true`。否则返回 `false`。

`CARTDATA` 在每次卡带执行的时候只能调用一次，所以只能使用一个数据槽位。

一旦设置了 Cartdata ID，内存区域 `0x5E00..0x5EFF` 会被映射到永久存储，要么直接访问，要么使用 `DGET()` / `DSET()` 访问。

刷新写入的数据是没有必要的 -- 数据会自动保存到永久存储，即使是直接用 `POKE()` 写入 `0x5E00..0x5EFF` 也不例外。

### DGET(INDEX)

获取 `INDEX`（`0..63`）处的数字。

只在你调用完 `CARTDATA()` 后使用这个函数。

### DSET(INDEX, VALUE)

设置 `INDEX`（`0..63`）处存储的数字。

只在你调用完 `CARTDATA()` 后使用这个函数。

## 6.12 GPIO

GPIO 代表“通用输入输出（General Purpose Input Output）”，它能允许机器之间互相通信。PICO-8 把内存区域 `0x5F80..0x5FFF` 映射到 GPIO 引脚，这样就能使用 `POKE()`（来输出一个值 -- 例如，点亮一个 LED）或 `PEEK()`（例如，读取开关的状态）。

对于不同的宿主平台，GPIO 意味着不同的东西：

CHIP：`0x5F80..0x5F87` 映射到 xio-p0..xio-p7  
PocketCHIP：`0x5F82..0x5F87` 映射到 GPIO1..GPIO6  
// xio-p0 & p1 暴露在外壳内的原型区域内。  
树莓派：`0x5F80..0x5F9F` 映射到 wiringPi 引脚 0..31  
// 查阅 http://wiringpi.com/pins/ 了解不同型号上的映射。  
// 还要注意 BCM 和 WiringPi GPIO 索引的不同！

CHIP 和树莓派的值都是数字的：0（低电平）和 255（高电平）。

一个程序，功能是闪烁任何连接的 LED：

``````lua
T = 0
FUNCTION _DRAW()
 CLS(5)
 FOR I=0,7 DO
  VAL = 0
  IF (T % 2 < 1) VAL = 255
  POKE(0X5F80 + I, VAL)
  CIRCFILL(20+I*12,64,4,VAL/11)
 END
 T += 0.1
END
``````

### 串行

若要更精确的时序，可以使用 `SERIAL()` 命令。GPIO 写入操作会进入缓冲，在每帧的末尾分发，这就允许手动使用 `POKE()` 调用进行 Bit-banging，从而让时钟以更高并且 / 或更有规律的速度循环。

### SERIAL(CHANNEL, ADDRESS, LENGTH)

`CHANNEL`：

`0x000..0x0FE`：对应 GPIO 引脚号；发送 `0x00` 表示低电平，或发送 `0xFF` 表示高电平  
`0x0FF`：延时，代表持续时长，以微秒为单位（不包括 Overhead）  
`0x400..0x401`：ws281x LED 字符串（实验性）

`ADDRESS`：要读取 / 写入的 PICO-8 内存地址。

`LENGTH`：发送的字节数。允许用 1/8 这样的分数发送部分比特串。

例如，一次一比特地给一个典型的 APA102 LED 灯珠发送一个字节：

``````lua
VAL = 42          -- 要发送的数值
DAT = 16 CLK = 15 -- 数据和时钟引脚，取决于设备
POKE(0X4300,0)    -- 要发送的数据（单字节：0 或 0xFF）
POKE(0X4301,0XFF)
FOR B=0,7 DO
  -- 发送比特（高位优先）
  SERIAL(DAT, BAND(VAL, SHL(1,7-B))>0 AND 0X4301 OR 0X4300, 1)
  -- 循环时钟
  SERIAL(CLK, 0X4301)
  SERIAL(0XFF, 5) -- 延迟 5
  SERIAL(CLK, 0X4300)
  SERIAL(0XFF, 5) -- 延迟 5
END
``````

还有额外的通道用于出入宿主操作系统的字节流。开发工具链的时候，这些通道在类 UNIX 环境下最有用，运行 BBS 或导出的卡带时则不可用[^1]。所有情形下，最大传输率是 64k / 秒（阻塞 CPU）。

`0x800`：拖放文件 // 数据可用时，`stat(120)` 会返回 `true`  
`0x802`：拖放图像 // 数据可用时，`stat(121)` 会返回 `true`  
`0x804`：Stdin  
`0x805`：Stdout  
`0x806`：用 `pico8 -i filename` 指定的文件  
`0x807`：用 `pico8 -o filename` 指定的文件

拖放到 PICO-8 的图像文件会以字节流的形式出现在通道 `0x802`，带有特殊的格式：开头的 4 个字节是图像的宽度和高度（每个 2 字节，小端字节序，类似 `PEEK2`），紧随其后的是依照阅读顺序的图像，每个像素一个字节，颜色会贴合到文件拖放时的显示调色板。

[^1]: 导出的二进制文件中，通道 `0x800` 和 `0x802` 是可用的，但是文件最大大小是 256k，图像最大大小是 128x128。

### HTML

导出为 HTML / .js 的卡带使用一个全局整数数组（`pico8_gpio`）代表 GPIO 引脚。外壳 HTML 应该这样定义这个数组：

``````js
var pico8_gpio = Array(128);
``````

## 6.13 鼠标和键盘输入

// 实验性 -- 但是基本上在所有平台都能运作

可以通过启用 Devkit 输入模式接受鼠标和键盘输入：

`POKE(0x5F2D, flags)` -- 其中 `flags` 是：

`0x1` 启用  
`0x2` 鼠标按钮触发 `btn(4)..btn(6)`  
`0x4` 锁定鼠标指针（使用 `STAT(38..39)` 读取移动信息）  

注意不是所有的 PICO-8 都连接了键盘或鼠标，所以在 Lexaloffle BBS 上发布卡带的时候，如果可以的话，建议把键鼠控制作为可选项，并且默认关闭。启用 Devkit 输入模式的时候会显示一条消息，警告 BBS 用户，这个程序可能会期望超出标准 6 按键控制器范围的输入。

鼠标和键盘的状态可以用 `STAT(X)` 查询：

`STAT(30)` -- （布尔值）有按键的时候为 `true`  
`STAT(31)` -- （字符串） 键盘返回的字符  
`STAT(32)` -- 鼠标 X 轴  
`STAT(33)` -- 鼠标 Y 轴  
`STAT(34)` -- 鼠标按钮（位域）  
`STAT(36)` -- 鼠标滚轮事件  
`STAT(38)` -- 相对 X 轴移动（以宿主桌面像素为单位） -- 需要开启标志 `0x4`  
`STAT(39)` -- 相对 Y 轴移动（以宿主桌面像素为单位） -- 需要开启标志 `0x4`

## 6.14 额外的 Lua 特性

PICO-8 还给高级用户开放了 2 个 Lua 特性：元表（Metatable）和协程（Coroutine）。

要获取更多信息，请查阅 Lua 5.2 手册。

### 元表

元表用来定义对象在特定操作下的行为。例如，要用表来表示可以相加的 2D 向量，可以通过在元表中定义一个  `__add` 函数来重定义 `+` 运算符：

``````lua
VEC2D={
 __ADD=FUNCTION(A,B)
  RETURN {X=(A.X+B.X), Y=(A.Y+B.Y)}
 END
}
 
V1={X=2,Y=9} SETMETATABLE(V1, VEC2D)
V2={X=1,Y=5} SETMETATABLE(V2, VEC2D)
V3 = V1+V2
PRINT(V3.X..","..V3.Y) -- 3,14
``````

#### SETMETATABLE(TBL, M)

设置表 `TBL` 的元表为 `M`。

#### GETMETATABLE(TBL)

返回表 `TBL` 的当前元表，如果没有设置就返回 `NIL`。

#### RAWSET(TBL, KEY, VALUE)

#### RAWGET(TBL, KEY)

#### RAWEQUAL(TBL1,TBL2)

#### RAWLEN(TBL)

对表进行原始访问，就好像没有定义元方法一样。

### 函数参数

函数参数列表可以用 `...` 指定。

``````lua
FUNCTION PREPRINT(PRE, S, ...)
  LOCAL S2 = PRE..TOSTR(S)
  PRINT(S2, ...) -- 把剩下的参数传递给 PRINT()
END
``````

要接受可变数量的参数，用它们定义一个表并且 / 或使用 Lua 的 `SELECT()` 函数。`SELECT(index, ...)` 返回 `index` 之后的所有参数。

``````lua
FUNCTION FOO(...)
  LOCAL ARGS={...} -- 构造参数组成的表
  FOREACH(ARGS, PRINT)
  ?SELECT("#",...)    -- 另一种计算参数数量的方法
  FOO2(SELECT(3,...)) -- 把索引 3 之后的参数传递给 FOO2()
END
``````

### 协程

协程提供了以一种并发的方式运行程序的不同部分，类似线程。一个函数可以作为协程调用，用 `YIELD()` 挂起任意次，之后在同一个地方恢复运行。

``````lua
FUNCTION HEY()
  PRINT("DOING SOMETHING")
  YIELD()
  PRINT("DOING THE NEXT THING")
  YIELD()
  PRINT("FINISHED")
END
 
C = COCREATE(HEY)
FOR I=1,3 DO CORESUME(C) END
``````

#### COCREATE(F)

为函数 `F` 创建一个协程。

#### CORESUME(C, [P0, P1 ..])

运行或恢复运行协程 `C`。参数 `P0`，`P1` .. 会传递到协程的函数。

如果协程执行完毕且没有任何错误，返回 `true`。如果有错误，返回 `false, error_message`。

** 协程内发生的运行时错误不会导致程序停止运行。最好把 `CORESUME()` 用 `ASSERT()` 包裹。这样如果断言失败，程序就会打印 `CORESUME` 生成的错误消息。

``````lua
ASSERT(CORESUME(C))
``````

#### COSTATUS(C)

以字符串的形式返回协程 `C` 的状态：

`"running"`  
`"suspended"`  
`"dead"`

#### YIELD

挂起执行并返回到调用者。

# 7 附录

## 7.1 附录 A：P8SCII 控制代码

用 `PRINT()` 打印的时候，有些字符有特殊含义，可以用来影响像是光标位置和文本渲染风格之类的东西。PICO-8 里的控制字符是 `CHR(0)..CHR(15)`，可以用转义序列书写（`\n` 代表换行等等）。

下列的部分控制代码接受参数，参数以一种十六进制格式超集的方案书写。具体来说，`'0'..'f'` 同样表示 `0..15`。但是 `'f'` 之后的字符也是接受的：`'g'` 表示 `16` ，以此类推。这样的参数在下文是以 `P0`，`P1` 来表示的。

例如，打印时带有蓝色的背景色（`\#c`）和深灰色的前景色（`\f5`）：

``````lua
PRINT("\#C\F5 BLUE ")
``````

绘制状态上唯一的副作用是光标位置和前景色的改变；每次调用 `PRINT()` 都会重置其它属性。

### 控制代码

| 代码 | 转义序列 | 含义                                        |
| ---- | -------- | ------------------------------------------- |
| 0    | \0       | 终止打印                                    |
| 1    | \\*      | 重复下一个字符 `P0` 次。`?"\*3a"` --> `aaa` |
| 2    | \\#      | 用颜色 `P0` 绘制纯色背景色                  |
| 3    | \\-      | 光标水平移动 `P0-16` 像素                   |
| 4    | \\\|     | 光标垂直移动 `P0-16` 像素                   |
| 5    | \\+      | 光标移动 `P0-16`，`P1-16` 像素              |
| 6    | \\^      | 特殊命令（见下文）                          |
| 7    | \a       | 音频（见下文）                              |
| 8    | \b       | 退格符                                      |
| 9    | \t       | 制表符                                      |
| A    | \n       | 换行符                                      |
| B    | \v       | 装饰前一个字符（见下文）                    |
| C    | \f       | 设置前景色                                  |
| D    | \r       | 卡带返回                                    |
| E    | \014     | 切换到内存地址 `0x5600` 定义的字体          |
| F    | \015     | 切换到默认字体                              |

### 特殊命令

这些命令都以 `\^` 开始，接受多达 2 个参数（`P0`，`P1`）。例如，要用深蓝色清屏：`PRINT("\^c1")`。

| 命令 | 含义                                              |
| ---- | ------------------------------------------------- |
| 1..9 | 跳过 1，2，4，8，16，32 .. 256 帧                 |
| c    | 用颜色 `P0` 清屏，设置光标坐标为 0，0             |
| d    | 对于打印的每个字符，设置延迟 `P0` 帧              |
| g    | 设置光标位置为原点坐标                            |
| h    | 设置原点坐标为光标位置                            |
| j    | 跳转到绝对坐标 `P0*4`，`P1*4`（以屏幕像素为单位） |
| r    | 设置右值字符换行边界为 `P0*4`                     |
| s    | 设置制表符宽度为 `P0` 像素（由 `\t` 使用）        |
| u    | 下划线                                            |
| x    | 设置字符宽度（默认值：4）                         |
| y    | 设置字符高度（默认值：6）                         |

### 渲染模式选项

// 在这些选项前面加 `-` 前缀来禁用：例如 `?"\^i 打开 \^-i 关闭"`

| 选项 | 含义                                           |
| ---- | ---------------------------------------------- |
| w    | 宽模式：缩放 2x1                               |
| t    | 高模式：缩放 1x2                               |
| =    | 条纹模式：宽模式或高模式下，只绘制偶数像素     |
| p    | 弹珠模式：等价于设置宽，高和条纹模式           |
| i    | 反转颜色                                       |
| b    | 边界：切换左侧和上侧的 1px 内边距 // 默认是开  |
| #    | 纯色背景 // 默认是关，但是使用 `\#` 会自动启用 |

### 原始内存写入

下列两个命令接受 4 字符的十六进制参数：

| 命令              | 含义                                |
| ----------------- | ----------------------------------- |
| @addrnnnn[binstr] | 向内存地址 `addr` 写入字节 `nnnn`   |
| !addr[binstr]     | 把剩下的所有字符写入内存地址 `addr` |

例如，写入 4 个字节到屏幕下半部分的视频内存：

``````lua
>?"\^@70000004xxxxhello"
``````

### 一次性字符

可以指定字符数据并打印到行内。使用 `\^.`，后面跟着 8 字节的原始二进制数据，或者使用 `\^:`，后面跟着 8 个 2 位十六进制数。数据格式和自定义字体相同；每个字节指定了一行 1 位像素值，低位在左边。

`\^.[8个字节的原始二进制数据]`  
`\^:[16个字符的十六进制数]`

要打印一只猫：

``````lua
> ?"\^:447cb67c3e7f0106"
``````

`.` 和 `:` 总是渲染没有填充的 8x8 字符。要维持目前的填充状态，可改用 `,` 和 `;` 。

```lua
?"\#3\^;447cb67c3e7f0106"
```

### P8SCII 轮廓

轮廓命令在字符的每个像素的相邻位置绘制像素，相邻位置多达 8 种，由一个 8 位位域提供。相邻位置的位值从左上角的低位开始，按照阅读顺序递增：

> `0x01`	`0x02`	`0x04`
>
> `0x08`	`----`	`0x10`
>
> `0x20`	`0x40`	`0x80`

命令 `\^o` 后的第一个字符是颜色，紧随其后的两个字符是十六进制的相邻位域。例如，要在每个前景像素的左上角绘制一个像素，可以使用值 `0x01` ：

```lua
?"\^o801hey"
```

下列代码在每个前景像素的左边、右边、上方和下方都绘制一个蓝色像素，这些位置对应到位上就是 `8+16+2+64 = 90` ，写成十六进制就是 `0x08+0x10+0x02+0x40 = 0x5a` ：

```lua
?"\f7\^oc5aoutline"
```

最后，置所有位可以得到完整的轮廓。轮廓可以和高、宽命令结合使用，但是轮廓绘制的厚度依然只有 1 像素：

```lua
?"\fe\^w\^t\^o7ffchunky"
```

绘制带轮廓的字符比起不带轮廓的消耗大约两倍的 CPU。

轮廓颜色参数可以设置为 `$` 以使用当前颜色，或设置为 `!` 以使用当前颜色的同时不绘制内部的像素。

```lua
?" \^o!ff empty interior"
```

### 音频

`?"\A"` -- 嘟嘟一声 `?"\A12"` -- 播放 SFX 12 的已有数据

如果没有指定 SFX 索引，就会自动选择 `60..63` 之间的未激活的 SFX。回放前若要给 SFX 填充数据，下列命令可以在后面追加。

1. （可选）SFX 属性必须在开头只出现一次，因为它们应用于整个声音：

`s P0`：设置 SFX 速度  
`l P0 P1`：设置 SFX 循环的起始点和结束点

2. 音符数据：

音符写作 `a..g`，可选的，后面可以跟着升调符号 `#` 或降调符号 `-`，以及八度号。

``````lua
PRINT "\ACE-G" -- 小三和弦
``````

空音符可以用一个点来书写：

``````lua
PRINT "\AC..E-..G" -- 断奏小三和弦
``````

音符属性命令应用于后面的音符：

`i P0`：设置乐器（默认值：5）  
`v P0`：设置音量（默认值：5）  
`x P0`：设置效果（默认值：0）  
`< >` 音量增加或减少 1

例如，要弹奏从 C1 开始的快速（速度 4），断奏（效果 5）的琶音：

``````lua
PRINT "\AS4X5C1EGC2EGC3EGC4"
``````

### 装饰字符

控制字符 `\v` 的用途是用另一个字符在给定的偏移位置上给上一个打印的字符装饰，而无需管理光标位置。打印完装饰字符后，恢复先前的光标位置。

格式是 `\v P0 char`，其中 `P0` 是提供想要的偏移值，`char` 是在那个偏移位置（相对于先前打印的字符）打印的任意字符。

偏移值中，X 坐标位于低 2 位，按照阅读顺序从（-2，-8）开始。所以 3 的意思是（+1，-8），4 的意思是（-2，-7），以此类推。

例如，要书写 `café!`，使用一个逗号来绘制尖音符号：

``````lua
PRINT"\NCAFE\VB,!"
``````

在这种情况下，`P0` 是 `B`，读作数字 11。所以逗号绘制在：

`x = (11%4)-2 = 1`  
`y = (11\4)-8 = -6`

### 自定义字体

可以在内存地址 `0x5600` 定义一个自定义字体，总大小是每个字符 8 字节 * 256 个字符 = 2048 字节。每个字符是一个 8x8 的位域（1 位 / 像素），其从顶部开始，每一行是一个单一字节，在左侧以 `0x1` 开始。

开头的 128 字节（字符 0~15 永远不会被绘制）描述字体的属性：

| 内存地址 | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| 0x5600   | 字符宽度，以像素为单位（可以大于 8，但是只会绘制 8 个像素）  |
| 0x5601   | 字符宽度，对于字符 128 及其后面的字符                        |
| 0x5602   | 字符高度，以像素为单位                                       |
| 0x5603   | 绘制偏移 X 值                                                |
| 0x5604   | 绘制偏移 Y 值                                                |
| 0x5605   | 标志：`0x1`：应用大小调整信息，`0x2`：相对光标原点应用制表符 |
| 0x5606   | 制表符宽度，以像素为单位（仅当绘制替代字体的时候使用）       |
| 0x5607   | 未使用                                                       |

剩下的 120 字节用于调整字符 `16..255` 的宽度和垂直偏移。每个半字节（低半字节优先）描述了一个字体的调整信息：

位 `0x7`：字符宽度调整量，分别是 0，1，2，3，-4，-3，-2，-1  
位 `0x8`：置位的时候，绘制高一个像素的字符（对于拉丁重音符号比较有用）

### 默认属性

虽然每次调用 `PRINT()` 后，属性会被重置，但是可以通过写入内存地址 `0x5F58..0x5F5B` 设置它们的默认值。

`0x5F58`：// 位域

| 位   | 描述                                   |
| ---- | -------------------------------------- |
| 0x1  | 设置为 `0x1` 的时候，才会检测位 `1..7` |
| 0x2  | 内边距                                 |
| 0x4  | 宽                                     |
| 0x8  | 高                                     |
| 0x10 | 纯色背景                               |
| 0x20 | 反转颜色                               |
| 0x40 | 条纹（有宽或高的时候）                 |
| 0x80 | 使用自定义字体                         |

// 例如 `POKE(0x5F58, 0x1 | 0x2 | 0x4 | 0x8 | 0x20 | 0x40)` -- 全是弹珠模式

`0x5F58`：字符宽度（低半字节），字符高度（高半字节）  
`0x5F58`：字符宽度 2（低半字节），制表符宽度（高半字节）  
`0x5F58`：绘制偏移 X 值（低半字节），绘制偏移 Y 值（高半字节）

// 任何等于 0 的半字节都会被忽略  
// 全局制表符宽度被映射到了 `4..60`
